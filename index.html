<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Ball Drop</title>
  <style>
    html, body { 
      height: 100%; 
      margin: 0; 
      padding: 0; 
      background: #0a1f0f; 
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; 
      color: #e0ffe0;
      touch-action: manipulation;
      overflow: hidden;
    }
    body { 
      display: flex; 
      flex-direction: column; 
    }

    .hud { 
      position: fixed; 
      top: 0; 
      left: 0; 
      right: 0; 
      height: 80px; 
      display: flex; 
      align-items: center; 
      justify-content: space-between;
      padding: 12px 16px; 
      box-sizing: border-box; 
      z-index: 10; 
      background: rgba(5, 30, 10, 0.95);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(100, 255, 100, 0.2);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    .score { 
      font-weight: 900; 
      font-size: 22px; 
      color: #a8ff80; 
      letter-spacing: 1.5px; 
      text-shadow: 0 0 10px rgba(160, 255, 120, 0.5);
      transition: transform 0.2s ease;
    }
    .score.highlight {
      color: #ffdd00;
      text-shadow: 0 0 15px rgba(255, 220, 0, 0.8);
      transform: scale(1.1);
    }
    .info { 
      display: flex; 
      flex-direction: column; 
      align-items: flex-end; 
      gap: 2px; 
      font-size: 12px; 
      color: #c0e0c0;
      text-align: right;
    }
    .level { 
      font-weight: 700; 
      color: #ffd700; 
      background: rgba(255, 215, 0, 0.1); 
      padding: 2px 6px; 
      border-radius: 4px;
    }
    .next { 
      display: flex; 
      align-items: center; 
      gap: 10px; 
      color: #d0f0d0; 
      font-size: 14px; 
      font-weight: 600;
    }
    .next canvas { 
      width: 42px; 
      height: 42px; 
      image-rendering: pixelated; 
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
    }
    .btn { 
      width: 48px; 
      height: 48px; 
      display: grid; 
      place-items: center; 
      border-radius: 50%; 
      background: rgba(255, 255, 255, 0.1); 
      border: none; 
      color: white; 
      cursor: pointer; 
      margin-left: 10px;
      transition: all 0.2s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }
    .btn:hover { 
      background: rgba(255, 255, 255, 0.2); 
      transform: scale(1.05);
    }

    #wrap { 
      position: relative; 
      flex: 1; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      padding: 80px 10px 10px;
      overflow: hidden;
    }
    #game { 
      width: 100%; 
      max-width: 480px; 
      height: 720px; 
      max-height: calc(100vh - 100px); 
      background: #1a4d2a; 
      border-radius: 16px; 
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), inset 0 0 0 1px rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(100, 200, 100, 0.2);
    }

    .center { 
      position: absolute; 
      inset: 0; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      pointer-events: none; 
    }
    .overlay { 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      gap: 20px; 
      color: white; 
      text-align: center; 
      padding: 30px;
      border-radius: 20px;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      max-width: 85%;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      pointer-events: auto;
      transform: scale(0.9);
      opacity: 0;
      transition: all 0.3s ease;
    }
    .overlay.visible {
      transform: scale(1);
      opacity: 1;
    }
    .title { 
      font-size: 32px; 
      font-weight: 900; 
      color: #ff5555;
      text-shadow: 0 3px 8px rgba(0,0,0,0.7);
    }
    .score-final {
      font-size: 20px;
      color: #aaffaa;
      font-weight: 700;
    }
    .restart { 
      padding: 16px 30px; 
      border-radius: 14px; 
      border: none; 
      font-weight: 700; 
      font-size: 18px; 
      cursor: pointer; 
      background: #e63946; 
      color: white; 
      box-shadow: 0 6px 16px rgba(230, 57, 70, 0.5);
      transition: all 0.2s ease;
    }
    .restart:hover { 
      background: #c1121f; 
      transform: translateY(-2px);
    }

    .hint { 
      position: fixed; 
      bottom: 16px; 
      left: 50%; 
      transform: translateX(-50%) translateY(20px);
      color: #c8ffd2; 
      font-size: 13px; 
      background: rgba(0, 0, 0, 0.6); 
      padding: 8px 16px; 
      border-radius: 12px; 
      z-index: 10;
      opacity: 0;
      transition: all 0.4s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      pointer-events: none;
    }
    .hint.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    canvas { 
      image-rendering: -moz-crisp-edges; 
      image-rendering: pixelated; 
      image-rendering: crisp-edges;
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="score" id="score">PUNTEGGIO 000000</div>
    <div class="info">
      <div class="next">
        <span>Prossimo</span>
        <canvas id="nextIcon" width="48" height="48"></canvas>
      </div>
      <div class="level" id="level">LIVELLO 1</div>
    </div>
    <button class="btn" id="pauseBtn" aria-label="Pausa">
      <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5">
        <circle cx="12" cy="12" r="9" stroke-opacity="0.3"/>
        <path d="M10 8v8M14 8v8" stroke-linecap="round"/>
      </svg>
    </button>
  </div>

  <div id="wrap">
    <canvas id="game" width="480" height="720" aria-label="Campo di gioco"></canvas>
    <div class="center">
      <div id="gameOver" class="overlay hidden">
        <div class="title">GAME OVER</div>
        <div class="score-final" id="finalScore">PUNTEGGIO: 0</div>
        <div class="score-final" id="bestScore">RECORD: 0</div>
        <button class="restart" id="restartBtn">Rigioca</button>
      </div>
    </div>
  </div>

  <div class="hint" id="hint">Tocca per far cadere una palla — unisci due uguali!</div>

<script>
(() => {
  /* ==========================
     CONFIGURAZIONE
  ========================== */
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // Sfondo erboso
  const grass = document.createElement('canvas');
  grass.width = grass.height = 128;
  const gctx = grass.getContext('2d');
  gctx.fillStyle = '#1a4d2a';
  gctx.fillRect(0, 0, 128, 128);
  for (let i = 0; i < 200; i++) {
    gctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.06})`;
    gctx.fillRect(Math.random() * 128, Math.random() * 128, 1, 1);
  }
  for (let i = 0; i < 40; i++) {
    gctx.strokeStyle = `rgba(255,255,255,${Math.random() * 0.1})`;
    gctx.lineWidth = 0.5;
    gctx.beginPath();
    gctx.moveTo(0, i * 3 + Math.random() * 2);
    gctx.lineTo(128, i * 3 + Math.random() * 2);
    gctx.stroke();
  }
  const grassPat = ctx.createPattern(grass, 'repeat');

  // Tipi di palle
  const TYPES = [
    'golf','pingpong','squash','lacrosse','tennis','baseball','cricket','pallamano','pallavolo','basket','waterpolo','calcio','pallamedica',
    'bomba', 'vetro', 'vortice'
  ];
  const SCORE_STEP = [10,20,40,80,120,180,260,360,520,700,900,1000];
  const RADII = {
    golf:18, pingpong:20, squash:22, lacrosse:24, tennis:26, baseball:28, cricket:30, pallamano:32, pallavolo:36, basket:40, waterpolo:42, calcio:44, pallamedica:50,
    bomba: 30, vetro: 28, vortice: 32
  };
  const MASSE = {
    golf:0.046, pingpong:0.0027, squash:0.024, lacrosse:0.145, tennis:0.058, baseball:0.145, cricket:0.163, pallamano:0.475, pallavolo:0.27, basket:0.62, waterpolo:0.45, calcio:0.43, pallamedica:3.0,
    bomba: 0.8, vetro: 0.1, vortice: 0.3
  };
  const REST = {
    golf:.75, pingpong:.88, squash:.7, lacrosse:.65, tennis:.8, baseball:.55, cricket:.55, pallamano:.5, pallavolo:.65, basket:.75, waterpolo:.6, calcio:.72, pallamedica:.35,
    bomba: 0.4, vetro: 0.9, vortice: 0.6
  };
  const FRICTION = 0.004;
  const MERGE_SPEED_THRESHOLD = 480;

  // Meccaniche di livello
  let level = 1;
  const LEVEL_THRESHOLD = 500;
  const BASE_G = 1200;
  let G = BASE_G;

  // ✅ ZONA PERICOLOSA IN ALTO
  const BASE_DANGER_HEIGHT = 120;  // Parte da 120px dall'alto
  let gameOverY = BASE_DANGER_HEIGHT;  // La linea rossa scende col livello

  // Palle speciali
  const SPECIAL_TYPES = new Set(['bomba', 'vetro', 'vortice']);
  const SPECIAL_CHANCE = 0.1;

  // Stato globale
  let balls = [];
  let paused = false;
  let gameOver = false;
  let score = 0;
  let bestScore = parseInt(localStorage.getItem('ballDropBest') || '0');
  let highestTypeIndex = 0;
  let dropping = false;
  let spawnY = 60;
  let vortexEffect = null;

  const R = (a, b) => a + Math.random() * (b - a);

  // Colori
  const COLORS = {
    golf: '#f5f5f5', pingpong: '#f8f8f8', squash: '#ffdd55', lacrosse: '#ffffff',
    tennis: '#ccff33', baseball: '#f5f5dc', cricket: '#fffaf0', pallamano: '#f0e6d2',
    pallavolo: '#ffffff', basket: '#e2720e', waterpolo: '#0077be', calcio: '#000000',
    pallamedica: '#6a6a6a',
    bomba: '#8b0000',
    vetro: '#ffffff',
    vortice: '#7b68ee'
  };

  // Cache sprite
  const spriteCache = new Map();
  function getSprite(type) {
    if (spriteCache.has(type)) return spriteCache.get(type);
    const r = RADII[type];
    const s = Math.ceil(r * 2 * DPR + 10);
    const c = document.createElement('canvas');
    c.width = c.height = s;
    const cx = c.getContext('2d');
    cx.translate(s / 2, s / 2);

    cx.beginPath();
    cx.arc(0, 0, r * DPR, 0, Math.PI * 2);
    if (type === 'vetro') {
      cx.globalAlpha = 0.2;
      cx.fillStyle = '#ffffff';
      cx.fill();
      cx.globalAlpha = 1;
    } else {
      cx.fillStyle = COLORS[type] || '#fff';
      cx.fill();
    }

    const grad = cx.createRadialGradient(-r * 0.4 * DPR, -r * 0.4 * DPR, 1, 0, 0, r * DPR);
    grad.addColorStop(0, 'rgba(255,255,255,0.5)');
    grad.addColorStop(0.4, 'rgba(255,255,255,0.2)');
    grad.addColorStop(1, 'rgba(0,0,0,0.1)');
    cx.fillStyle = grad;
    cx.fill();

    if (type === 'bomba') {
      cx.fillStyle = '#8b0000';
      cx.fill();
      cx.strokeStyle = '#000';
      cx.lineWidth = 2 * DPR;
      cx.beginPath();
      cx.moveTo(-r * 0.6 * DPR, -r * 0.6 * DPR);
      cx.lineTo(-r * 0.9 * DPR, -r * 0.9 * DPR);
      cx.stroke();
      cx.fillStyle = '#ff9900';
      cx.beginPath();
      cx.moveTo(-r * 0.9 * DPR, -r * 0.9 * DPR);
      cx.lineTo(-r * 1.1 * DPR, -r * 1.1 * DPR);
      cx.lineTo(-r * 0.8 * DPR, -r * 1.0 * DPR);
      cx.closePath();
      cx.fill();
    }

    if (type === 'vetro') {
      cx.strokeStyle = '#ffffff';
      cx.lineWidth = 2 * DPR;
      cx.setLineDash([3 * DPR, 3 * DPR]);
      cx.stroke();
      cx.setLineDash([]);
    }

    if (type === 'vortice') {
      cx.strokeStyle = '#ffffff';
      cx.lineWidth = 2 * DPR;
      for (let i = 0; i < 3; i++) {
        cx.beginPath();
        const steps = 50;
        for (let j = 0; j < steps; j++) {
          const t = j / 10;
          const x = (t * 0.6 * Math.cos(t + i)) * r * DPR;
          const y = (t * 0.6 * Math.sin(t + i)) * r * DPR;
          if (j === 0) cx.moveTo(x, y);
          else cx.lineTo(x, y);
        }
        cx.stroke();
      }
    }

    spriteCache.set(type, c);
    return c;
  }

  // UI
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const finalScoreEl = document.getElementById('finalScore');
  const bestScoreEl = document.getElementById('bestScore');
  const nextIcon = document.getElementById('nextIcon');
  const nextCtx = nextIcon.getContext('2d');
  const pauseBtn = document.getElementById('pauseBtn');
  const overEl = document.getElementById('gameOver');
  const restartBtn = document.getElementById('restartBtn');
  const hintEl = document.getElementById('hint');

  function fmt(n) { return 'PUNTEGGIO ' + String(n).padStart(6, '0'); }

  function addScore(n, x, y) {
    score += n;
    scoreEl.textContent = fmt(score);
    scoreEl.classList.add('highlight');
    setTimeout(() => scoreEl.classList.remove('highlight'), 300);
    floatText(`+${n}`, x, y);

    const newLevel = Math.floor(score / LEVEL_THRESHOLD) + 1;
    if (newLevel > level) {
      level = newLevel;
      onLevelUp();
    }
  }

  function onLevelUp() {
    for (const b of balls) {
      b.rest = Math.max(0.25, REST[b.type] - (level - 1) * 0.05);
    }
    floatText(`LIVELLO ${level}!`, W / 2, H / 2);
    levelEl.textContent = `LIVELLO ${level}`;
    sfx('boing');
    ctx.filter = 'blur(2px)';
    setTimeout(() => ctx.filter = 'none', 100);
  }

  // Particelle
  const particles = [];
  function spawnStars(x, y) {
    for (let i = 0; i < 12; i++) {
      const size = R(2, 5) * DPR;
      particles.push({
        x, y,
        vx: R(-120, 120),
        vy: R(-180, -60),
        life: R(0.6, 1.0),
        t: 0,
        color: ['#ffd700', '#ffaa00', '#ffffff'][Math.floor(R(0, 3))],
        size,
        rotation: R(0, Math.PI * 2),
        type: 'star'
      });
    }
  }

  function floatText(t, x, y) {
    particles.push({
      text: t,
      x, y,
      vx: R(-20, 20),
      vy: -60,
      life: 1.0,
      t: 0,
      color: '#ffdd00',
      size: 20
    });
  }

  // Audio
  const Audio = new (window.AudioContext || window.webkitAudioContext)();
  let musicPlaying = false;

  function sfx(kind) {
    if (!musicPlaying) return;
    const g = Audio.createGain();
    g.connect(Audio.destination);
    g.gain.value = 0.15;
    const o = Audio.createOscillator();
    o.connect(g);
    const now = Audio.currentTime;

    switch (kind) {
      case 'tink': o.type = 'sine'; o.frequency.setValueAtTime(700, now); o.frequency.exponentialRampToValueAtTime(500, now + 0.1); break;
      case 'boing': o.type = 'triangle'; o.frequency.setValueAtTime(200, now); o.frequency.exponentialRampToValueAtTime(150, now + 0.15); break;
      case 'merge': o.type = 'sawtooth'; o.frequency.setValueAtTime(400, now); o.frequency.exponentialRampToValueAtTime(250, now + 0.2); break;
    }
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.3, now + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
    o.start(now);
    o.stop(now + 0.26);
  }

  // Input
  canvas.addEventListener('pointerdown', onPointer);
  function onPointer(e) {
    if (gameOver || paused || dropping) return;
    dropping = true;
    if (!musicPlaying) {
      musicPlaying = true;
      Audio.resume();
    }
    const rect = canvas.getBoundingClientRect();
    let x = (e.clientX - rect.left) / rect.width * W;

    const safe = balls.every(b => Math.hypot(b.x - x, b.y - spawnY) > b.r + 20);
    if (!safe) x = W / 2 + R(-100, 100);

    let type;
    if (level >= 3 && Math.random() < SPECIAL_CHANCE) {
      type = ['bomba', 'vetro', 'vortice'][Math.floor(Math.random() * 3)];
    } else {
      type = TYPES[Math.floor(R(0, Math.min(highestTypeIndex + 1, 5)))];
    }

    spawnBall(x, spawnY, type);
    sfx('tink');

    if (balls.length > 6) {
      hintEl.classList.remove('show');
    }

    setTimeout(() => { dropping = false; }, 250);
  }

  // Hint
  setTimeout(() => {
    hintEl.classList.add('show');
    setTimeout(() => hintEl.classList.remove('show'), 3000);
  }, 500);

  pauseBtn.addEventListener('click', () => {
    paused = !paused;
    pauseBtn.style.opacity = paused ? 0.6 : 1;
    if (paused) sfx('boing');
  });

  restartBtn.addEventListener('click', () => {
    document.location.reload();
  });

  // Fisica
  const dtFixed = 1 / 120;
  let acc = 0;
  let last = performance.now();

  function spawnBall(x, y, type) {
    const r = RADII[type];
    const m = MASSE[type];
    const b = {
      id: Math.random().toString(36).slice(2),
      type, x, y, vx: 0, vy: 0, r, m,
      rest: REST[type],
      squash: 0,
      merging: false,
      asleep: false
    };
    balls.push(b);
    if (!SPECIAL_TYPES.has(type)) {
      highestTypeIndex = Math.max(highestTypeIndex, TYPES.indexOf(type));
    }
    redrawNext();
    return b;
  }

  function redrawNext() {
    nextCtx.clearRect(0, 0, nextIcon.width, nextIcon.height);
    const idx = Math.min(highestTypeIndex + 1, TYPES.length - 1);
    const type = TYPES[idx];
    const s = getSprite(type);
    const sz = 36 * DPR;
    const x = (nextIcon.width - sz) / 2;
    const y = (nextIcon.height - sz) / 2;
    nextCtx.drawImage(s, x, y, sz, sz);
  }

  // Inizio
  for (let i = 0; i < 4; i++) {
    spawnBall(R(80, W - 80), R(100, 200), 'golf');
  }
  scoreEl.textContent = fmt(0);
  levelEl.textContent = `LIVELLO ${level}`;
  redrawNext();

  function update(dt) {
    if (paused || gameOver) return;

    // 🔄 Gravità e zona pericolosa
    G = BASE_G + (level - 1) * 100;
    gameOverY = Math.min(300, BASE_DANGER_HEIGHT + (level - 1) * 10); // Massimo 300px

    for (const b of balls) {
      if (b.asleep) continue;
      b.vy += G * dt;
      b.vx *= (1 - FRICTION);
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      // Muri
      if (b.x - b.r < 10) {
        b.x = 10 + b.r;
        b.vx = -b.vx * b.rest * 0.8;
      }
      if (b.x + b.r > W - 10) {
        b.x = W - 10 - b.r;
        b.vx = -b.vx * b.rest * 0.8;
      }
      if (b.y + b.r > H - 10) {
        b.y = H - 10 - b.r;
        const effectiveRest = Math.max(0.2, b.rest - (level - 1) * 0.04);
        b.vy = -Math.abs(b.vy) * effectiveRest;

        // 💎 Palla di vetro: si rompe
        if (b.type === 'vetro' && Math.abs(b.vy) < 30) {
          floatText('SHATTER!', b.x, b.y);
          sfx('boing');
          for (let i = 0; i < 10; i++) {
            particles.push({
              x: b.x, y: b.y,
              vx: R(-100, 100), vy: R(-150, 150),
              life: R(0.3, 0.7), t: 0,
              color: '#fff', size: R(2, 4)
            });
          }
          balls = balls.filter(ball => ball !== b);
          continue;
        }

        if (Math.abs(b.vy) < 15) b.vy = 0;
        if (Math.abs(b.vx) < 20) b.vx *= 0.95;
        if (Math.abs(b.vy) < 10 && Math.abs(b.vx) < 8) b.asleep = true;
      }
    }

    // Vortice
    if (vortexEffect) {
      vortexEffect.duration -= dt;
      if (vortexEffect.duration <= 0) {
        vortexEffect = null;
      } else {
        for (const b of balls) {
          if (b.type === 'vortice') continue;
          const dx = vortexEffect.x - b.x;
          const dy = vortexEffect.y - b.y;
          const dist = Math.hypot(dx, dy);
          if (dist < 120) {
            const force = (120 - dist) / 120 * 400 * dt;
            b.vx += (dx / dist) * force;
            b.vy += (dy / dist) * force;
          }
        }
      }
    }

    // Grid collision
    const cell = 64;
    const grid = new Map();
    function key(i, j) { return `${i},${j}`; }
    for (const b of balls) {
      const i = Math.floor(b.x / cell), j = Math.floor(b.y / cell);
      for (let ii = i - 1; ii <= i + 1; ii++) {
        for (let jj = j - 1; jj <= j + 1; jj++) {
          const k = key(ii, jj);
          if (!grid.has(k)) grid.set(k, []);
          grid.get(k).push(b);
        }
      }
    }

    const pairs = new Set();
    for (const arr of grid.values()) {
      for (let a = 0; a < arr.length; a++) {
        for (let d = a + 1; d < arr.length; d++) {
          const A = arr[a], B = arr[d];
          const id = A.id < B.id ? A.id + '|' + B.id : B.id + '|' + A.id;
          if (pairs.has(id)) continue;
          pairs.add(id);

          const dx = B.x - A.x, dy = B.y - A.y;
          const dist2 = dx * dx + dy * dy;
          const rr = A.r + B.r;
          if (dist2 > rr * rr) continue;

          const dist = Math.sqrt(dist2) || 1;
          const nx = dx / dist, ny = dy / dist;
          const overlap = rr - dist;
          const totalMass = A.m + B.m;
          const aShare = B.m / totalMass, bShare = A.m / totalMass;
          A.x -= nx * overlap * aShare;
          A.y -= ny * overlap * aShare;
          B.x += nx * overlap * bShare;
          B.y += ny * overlap * bShare;

          const rvx = B.vx - A.vx, rvy = B.vy - A.vy;
          const velAlongNormal = rvx * nx + rvy * ny;
          if (velAlongNormal < 0) {
            const e = Math.min(A.rest, B.rest);
            const j = -(1 + e) * velAlongNormal / (1 / A.m + 1 / B.m);
            const impX = j * nx, impY = j * ny;
            A.vx -= impX / A.m;
            A.vy -= impY / A.m;
            B.vx += impX / B.m;
            B.vy += impY / B.m;
            A.squash = B.squash = Math.min(1.5, Math.abs(velAlongNormal) / 400);
            A.asleep = B.asleep = false;
          }

          if (A.type === B.type && !A.merging && !B.merging && Math.hypot(rvx, rvy) < MERGE_SPEED_THRESHOLD) {
            mergeBalls(A, B);
          }
        }
      }
    }

    for (const b of balls) {
      if (!b.asleep && Math.abs(b.vx) < 0.1 && Math.abs(b.vy) < 0.1) {
        b.asleep = true;
      }
    }

    // ✅ GAME OVER: se una palla dormiente entra nella zona rossa in alto
    for (const b of balls) {
      if (b.asleep && b.y - b.r < gameOverY) {
        endGame();
        return;
      }
    }

    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.t += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 600 * dt;
      if (p.type === 'star') p.rotation += 0.2;
      if (p.t > p.life) particles.splice(i, 1);
    }
  }

  function endGame() {
    if (gameOver) return;
    gameOver = true;
    if (score > bestScore) {
      bestScore = score;
      localStorage.setItem('ballDropBest', bestScore);
    }
    finalScoreEl.textContent = `PUNTEGGIO: ${score}`;
    bestScoreEl.textContent = `RECORD: ${bestScore}`;
    overEl.classList.remove('hidden');
    setTimeout(() => overEl.classList.add('visible'), 100);
  }

  function mergeBalls(A, B) {
    sfx('merge');
    spawnStars((A.x + B.x) / 2, (A.y + B.y) / 2);

    if (A.type === 'bomba' || B.type === 'bomba') {
      explode((A.x + B.x) / 2, (A.y + B.y) / 2);
      balls = balls.filter(b => b !== A && b !== B);
      return;
    }

    const baseType = A.type;
    const idx = TYPES.indexOf(baseType);
    const scoreBonus = (A.type === 'vetro' || B.type === 'vetro') ? 3 : 1;

    if (idx < SCORE_STEP.length) {
      addScore(SCORE_STEP[idx] * scoreBonus, (A.x + B.x) / 2, (A.y + B.y) / 2);
    }

    A.merging = B.merging = true;
    const totalMass = A.m + B.m;
    const x = (A.x * A.m + B.x * B.m) / totalMass;
    const y = (A.y * A.m + B.y * B.m) / totalMass;
    const vx = (A.vx * A.m + B.vx * B.m) / totalMass;
    const vy = (A.vy * A.m + B.vy * B.m) / totalMass;

    balls = balls.filter(b => b !== A && b !== B);

    const nextIdx = Math.min(idx + 1, TYPES.length - 1);
    const newType = TYPES[nextIdx];
    const C = {
      id: Math.random().toString(36).slice(2),
      type: newType,
      x, y, vx, vy,
      r: RADII[newType],
      m: MASSE[newType],
      rest: REST[newType],
      squash: 0,
      merging: false,
      asleep: false
    };
    balls.push(C);
    if (!SPECIAL_TYPES.has(newType)) {
      highestTypeIndex = Math.max(highestTypeIndex, nextIdx);
    }
    redrawNext();

    if (newType === 'vortice') {
      vortexEffect = { x: C.x, y: C.y, duration: 2.0 };
      floatText('VORTICE!', C.x, C.y - 40);
      sfx('tink');
    }
  }

  function explode(x, y) {
    sfx('boing');
    floatText('BOOM!', x, y);
    for (let i = 0; i < 20; i++) {
      particles.push({
        x, y,
        vx: R(-200, 200),
        vy: R(-250, -60),
        life: R(0.5, 0.9),
        t: 0,
        color: ['#ff4500', '#ff8c00', '#ffd700'][Math.floor(R(0, 3))],
        size: R(3, 6) * DPR
      });
    }
    balls = balls.filter(b => {
      const dist = Math.hypot(b.x - x, b.y - y);
      if (dist < 80) {
        for (let i = 0; i < 5; i++) {
          particles.push({
            x: b.x, y: b.y,
            vx: R(-100, 100), vy: R(-150, 150),
            life: R(0.3, 0.7), t: 0,
            color: '#aaa', size: 2
          });
        }
        return false;
      }
      return true;
    });
  }

  function draw() {
    ctx.save();
    ctx.fillStyle = grassPat;
    ctx.fillRect(0, 0, W, H);

    // 🔴 ZONA PERICOLOSA IN ALTO
    ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
    ctx.fillRect(0, 0, W, gameOverY);

    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, gameOverY);
    ctx.lineTo(W, gameOverY);
    ctx.stroke();

    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 2;
    ctx.strokeRect(8, 8, W - 16, H - 16);
    ctx.restore();

    for (const b of balls) {
      const spr = getSprite(b.type);
      const sx = spr.width / 2, sy = spr.height / 2;
      const squ = 1 - Math.min(0.3, b.squash * 0.3);
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.scale(1 / squ, squ);
      ctx.shadowColor = 'rgba(0,0,0,0.3)';
      ctx.shadowBlur = 8;
      ctx.shadowOffsetY = 4;
      ctx.drawImage(spr, -sx, -sy, spr.width, spr.height);
      ctx.restore();
      b.squash *= 0.7;
    }

    // Vortice
    if (vortexEffect) {
      ctx.save();
      ctx.globalAlpha = 0.3;
      ctx.strokeStyle = '#7b68ee';
      ctx.lineWidth = 3;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(vortexEffect.x, vortexEffect.y, 40 + i * 20, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }

    ctx.save();
    for (const p of particles) {
      const alpha = 1 - p.t / p.life;
      ctx.globalAlpha = alpha;
      if (p.text) {
        ctx.font = `bold ${p.size}px sans-serif`;
        ctx.fillStyle = p.color;
        ctx.textAlign = 'center';
        ctx.fillText(p.text, p.x, p.y);
      } else {
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
        ctx.resetTransform();
      }
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function loop() {
    const now = performance.now();
    let dt = (now - last) / 1000;
    last = now;
    if (dt > 0.1) dt = 0.1;

    acc += dt;
    while (acc >= dtFixed) {
      update(dtFixed);
      acc -= dtFixed;
    }
    draw();
    requestAnimationFrame(loop);
  }

  loop();
})();
</script>
</body>
</html>
