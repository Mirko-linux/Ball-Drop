<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Ball Drop</title>
  <style>
    html, body { 
      height: 100%; 
      margin: 0; 
      padding: 0; 
      background: #0a1f0f; 
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; 
      color: #e0ffe0;
      touch-action: manipulation;
      overflow: hidden;
    }
    body { 
      display: flex; 
      flex-direction: column; 
    }
    /* nasconde elementi con classe .hidden */
    .hidden { display: none !important; }
    /* === MENU SYSTEM === */
    #menu-overlay {
      position: fixed;
      inset: 0;
      background: rgba(5, 30, 10, 0.95);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      z-index: 100;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    .menu-screen {
      display: none;
      text-align: center;
      max-width: 400px;
      width: 90%;
    }
    .menu-screen.active {
      display: block;
    }
    .menu-title {
      font-size: 36px;
      font-weight: 900;
      color: #a8ff80;
      margin: 0 0 30px;
      text-shadow: 0 0 10px rgba(160, 255, 120, 0.5);
      letter-spacing: 1px;
    }
    .menu-btn {
      display: block;
      width: 100%;
      padding: 14px;
      margin: 12px 0;
      border: none;
      border-radius: 14px;
      background: rgba(100, 200, 100, 0.2);
      color: #e0ffe0;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    .menu-btn:hover {
      background: rgba(160, 255, 120, 0.3);
      transform: translateY(-2px);
    }
    .menu-back {
      margin-top: 25px;
      background: rgba(255, 255, 255, 0.1);
      font-size: 16px;
    }
    .credits-text {
      color: #c0e0c0;
      line-height: 1.6;
      margin: 20px 0;
      font-size: 14px;
    }
    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 15px 0;
      color: #d0f0d0;
      font-size: 15px;
    }
    .toggle-btn {
      padding: 8px 16px;
      border-radius: 10px;
      border: none;
      background: #4caf50;
      color: white;
      font-weight: bold;
      cursor: pointer;
    }
    .toggle-btn.off { background: #f44336; }
    /* === HUD (nascosto all'avvio) === */
    .hud { 
      position: fixed; 
      top: 0; 
      left: 0; 
      right: 0; 
      height: 80px; 
      display: none;
      align-items: center; 
      justify-content: space-between;
      padding: 12px 16px; 
      box-sizing: border-box; 
      z-index: 10; 
      background: rgba(5, 30, 10, 0.95);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(100, 255, 100, 0.2);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    .hud.visible { display: flex; }
    .score { 
      font-weight: 900; 
      font-size: 22px; 
      color: #a8ff80; 
      letter-spacing: 1.5px; 
      text-shadow: 0 0 10px rgba(160, 255, 120, 0.5);
      transition: transform 0.2s ease;
    }
    .score.highlight {
      color: #ffdd00;
      text-shadow: 0 0 15px rgba(255, 220, 0, 0.8);
      transform: scale(1.1);
    }
    .info { 
      display: flex; 
      flex-direction: column; 
      align-items: flex-end; 
      gap: 2px; 
      font-size: 12px; 
      color: #c0e0c0;
      text-align: right;
    }
    .level { 
      font-weight: 700; 
      color: #ffd700; 
      background: rgba(255, 215, 0, 0.1); 
      padding: 2px 6px; 
      border-radius: 4px;
    }
    .next { 
      display: flex; 
      align-items: center; 
      gap: 10px; 
      color: #d0f0d0; 
      font-size: 14px; 
      font-weight: 600;
    }
    .next canvas { 
      width: 42px; 
      height: 42px; 
      image-rendering: pixelated; 
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
    }
    .btn { 
      width: 48px; 
      height: 48px; 
      display: grid; 
      place-items: center; 
      border-radius: 50%; 
      background: rgba(255, 255, 255, 0.1); 
      border: none; 
      color: white; 
      cursor: pointer; 
      margin-left: 10px;
      transition: all 0.2s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }
    .btn:hover { 
      background: rgba(255, 255, 255, 0.2); 
      transform: scale(1.05);
    }
    .powerups {
      display: flex;
      gap: 10px;
      font-size: 12px;
      color: #d0f0d0;
    }
    .powerup {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .powerup-icon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
    }
    .jolly-icon { background: #ffd700; border: 1px solid #ff9900; }
    .fuoco-icon { background: #ff4500; }
    #wrap { 
      position: relative; 
      flex: 1; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      padding: 80px 10px 10px;
      overflow: hidden;
    }
    #game { 
      width: 100%; 
      max-width: 480px; 
      height: 720px; 
      max-height: calc(100vh - 100px); 
      background: #1a4d2a; 
      border-radius: 16px; 
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), inset 0 0 0 1px rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(100, 200, 100, 0.2);
      touch-action: none;
      display: block;
    }
    .center { 
      position: absolute; 
      inset: 0; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      pointer-events: none; 
    }
    .overlay { 
      display: flex;
      flex-direction: column; 
      align-items: center; 
      gap: 20px; 
      color: white; 
      text-align: center; 
      padding: 30px;
      border-radius: 20px;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      max-width: 85%;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      pointer-events: auto;
      transform: scale(0.9);
      opacity: 0;
      transition: all 0.3s ease;
    }
    .overlay.visible {
      transform: scale(1);
      opacity: 1;
    }
    .title { 
      font-size: 32px; 
      font-weight: 900; 
      color: #ff5555;
      text-shadow: 0 3px 8px rgba(0,0,0,0.7);
    }
    .score-final {
      font-size: 20px;
      color: #aaffaa;
      font-weight: 700;
    }
    .restart { 
      padding: 16px 30px; 
      border-radius: 14px; 
      border: none; 
      font-weight: 700; 
      font-size: 18px; 
      cursor: pointer; 
      background: #e63946; 
      color: white; 
      box-shadow: 0 6px 16px rgba(230, 57, 70, 0.5);
      transition: all 0.2s ease;
    }
    .restart:hover { 
      background: #c1121f; 
      transform: translateY(-2px);
    }
    .hint { 
      position: fixed; 
      bottom: 16px; 
      left: 50%; 
      transform: translateX(-50%) translateY(20px);
      color: #c8ffd2; 
      font-size: 13px; 
      background: rgba(0, 0, 0, 0.6); 
      padding: 8px 16px; 
      border-radius: 12px; 
      z-index: 10;
      opacity: 0;
      transition: all 0.4s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      pointer-events: none;
    }
    .hint.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* === PAUSE MENU === */
/* --- Sostituisci il blocco #pauseMenu esistente con questo --- */
#pauseMenu {
  position: fixed;
  inset: 0; /* prende tutto lo schermo */
  display: flex;
  justify-content: center;
  align-items: center;

  /* sfondo leggermente trasparente + blur */
  background: rgba(5, 30, 10, 0.85);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);

  /* IMPORTANT: sopra gli altri overlay/hud */
  z-index: 260;

  /* inizialmente nascosto via opacity/pointer (non usando display:none
     cos√¨ le transizioni funzionano bene) */
  opacity: 0;
  pointer-events: none;
  transform: scale(0.98);
  transition: opacity 0.22s ease, transform 0.22s ease;
}

/* quando mostriamo il menu: diventa cliccabile e visibile */
#pauseMenu.visible {
  opacity: 1;
  pointer-events: auto;
  transform: scale(1);
}

/* quando √® nascosto (forza stato nascosto) */
#pauseMenu.hidden {
  opacity: 0;
  pointer-events: none;
  transform: scale(0.98);
}

    .pause-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      padding: 20px;
      border-radius: 16px;
      background: #4e342e;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      width: 80%;
      max-width: 300px;
      position: relative;
    }
    .pause-title {
      font-size: 28px;
      font-weight: 900;
      color: #ffeb3b;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      letter-spacing: 1px;
      margin: 0 0 15px;
    }
    .pause-btn {
      width: 100%;
      padding: 12px 20px;
      margin: 5px 0;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #ffca28, #ffb300);
      color: #4e342e;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 3px 6px rgba(0,0,0,0.2);
      text-transform: uppercase;
      font-size: 16px;
    }
    .pause-btn:hover {
      background: linear-gradient(135deg, #ffd54f, #ffc107);
      transform: translateY(-2px);
      box-shadow: 0 5px 10px rgba(0,0,0,0.3);
    }
    .pause-close {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #ff5722;
      color: white;
      font-size: 20px;
      line-height: 30px;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    .pause-close:hover {
      background: #ff4500;
      transform: scale(1.1);
    }

    /* === JOLLY SELECTOR === */
   #jollySelector {
   position: fixed;
   inset: 0; /* prende tutto lo schermo */
   display: flex;
   justify-content: center;
   align-items: center;
   background: rgba(5, 30, 10, 0.9);
   backdrop-filter: blur(10px);
   -webkit-backdrop-filter: blur(10px);
   z-index: 200; /* sopra HUD e canvas */
   }

    .selector-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      padding: 30px;
      border-radius: 20px;
      background: rgba(0, 0, 0, 0.7);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      max-width: 90%;
      width: 400px;
    }
    .selector-content h3 {
      font-size: 24px;
      color: #a8ff80;
      margin: 0;
    }
    .selector-controls {
      display: flex;
      align-items: center;
      gap: 20px;
    }
    .arrow-btn {
      width: 60px;
      height: 60px;
      display: grid;
      place-items: center;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }
    .arrow-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }
    .preview-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    .preview-name {
      font-size: 18px;
      color: #ffd700;
      font-weight: bold;
      text-align: center;
      min-height: 24px;
    }
    #previewCanvas {
      width: 80px;
      height: 80px;
      image-rendering: pixelated;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.2);
    }
    canvas { 
      image-rendering: -moz-crisp-edges; 
      image-rendering: pixelated; 
      image-rendering: crisp-edges;
    }
    body, canvas, * {
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <!-- MENU INIZIALE -->
  <div id="menu-overlay">
    <!-- SCHERMATA PRINCIPALE -->
    <div class="menu-screen active" id="screen-main">
      <div class="menu-title">BALL DROP</div>
      <button class="menu-btn" id="btnPlay">üéÆ GIOCA</button>
      <button class="menu-btn" id="btnOptions">‚öôÔ∏è OPZIONI</button>
      <button class="menu-btn" id="btnCredits">üìú CREDITI</button>
    </div>
    <!-- SCHERMATA OPZIONI -->
    <div class="menu-screen" id="screen-options">
      <div class="menu-title">OPZIONI</div>
      <div class="settings-row">
        <span>Audio</span>
        <button class="toggle-btn" id="btnToggleAudio">üîä ON</button>
      </div>
      <div class="settings-row">
        <span>Trucchi</span>
        <button class="toggle-btn" id="btnEnableCheats">OFF</button>
      </div>
      <button class="menu-btn menu-back" id="btnBackOptions">‚Üê INDIETRO</button>
    </div>
    <!-- SCHERMATA CREDITI -->
    <div class="menu-screen" id="screen-credits">
      <div class="menu-title">CREDITI</div>
      <p class="credits-text">
        Realizzato con ‚ù§Ô∏è da <strong>Mirko Yuri Donato</strong><br>
        Il gioco presenta parti realizzati mediante l'uso del-<br>
        l'intelligenza artificiale, principalmente i Modelli GPT 5 <br>
        Qwen 3 di Alibaba Cloud, DeepSeek e Microsoft Copilot <br>
        Il codice sorgente √® rilasciato sotto la licenza MIT,<br>
        mentre gli assets sono sotto la<br>
        Creative Commons Attribution 4.0 International Public License.
      </p>
      <button class="menu-btn menu-back" id="btnBackCredits">‚Üê INDIETRO</button>
    </div>
  </div>

  <!-- MENU PAUSA -->
  <div id="pauseMenu" class="overlay hidden">
    <div class="pause-content">
      <div class="pause-title">PAUSED</div>
      <button class="pause-btn" id="btnResume">RIPRENDI</button>
      <button class="pause-btn" id="btnRestartPause">RIAVVIA</button>
      <button class="pause-btn" id="btnOptionsPause">OPZIONI</button>
      <button class="pause-btn" id="btnQuit">ESCI</button>
      <button class="pause-close" id="btnClosePause">√ó</button>
    </div>
  </div>

  <!-- SELEZIONE JOLLY -->
  <div id="jollySelector" class="overlay hidden">
    <div class="selector-content">
      <h3>SELEZIONA PALLA</h3>
      <div class="selector-controls">
        <button class="arrow-btn" id="btnPrev">‚Üê</button>
        <div class="preview-box">
          <div class="preview-name" id="previewName">Vortice</div>
          <canvas id="previewCanvas" width="80" height="80"></canvas>
        </div>
        <button class="arrow-btn" id="btnNext">‚Üí</button>
      </div>
      <button class="restart" id="btnSelectJolly">SELEZIONA</button>
    </div>
  </div>

  <!-- HUD (nascosto finch√© non si gioca) -->
  <div class="hud">
    <div class="score" id="score">PUNTEGGIO 000000</div>
    <div class="info">
      <div class="next">
        <span>Prossimo</span>
        <canvas id="nextIcon" width="48" height="48"></canvas>
      </div>
      <div class="level" id="level">LIVELLO 1</div>
      <div class="powerups" id="powerups">
        <div class="powerup" id="jolly" style="display: none;">
          <div class="powerup-icon jolly-icon"></div>
          <span>Jolly</span>
        </div>
        <div class="powerup" id="fuoco" style="display: none;">
          <div class="powerup-icon fuoco-icon"></div>
          <span>Fuoco</span>
        </div>
      </div>
    </div>
    <div>
      <button class="btn" id="pauseBtn" aria-label="Pausa">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5">
          <circle cx="12" cy="12" r="9" stroke-opacity="0.3"/>
          <path d="M10 8v8M14 8v8" stroke-linecap="round"/>
        </svg>
      </button>
      <button class="btn" id="inventoryBtn" aria-label="Inventario" style="display: none;">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
          <path d="M4 7v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V7H4zm0-2h16v2H4V5zm4 4h8v2H8V9z"/>
        </svg>
      </button>
    </div>
  </div>

  <div id="wrap">
    <canvas id="game" width="480" height="720" aria-label="Campo di gioco"></canvas>
    <div class="center">
      <div id="gameOver" class="overlay hidden">
        <div class="title">GAME OVER</div>
        <div class="score-final" id="finalScore">PUNTEGGIO: 0</div>
        <div class="score-final" id="bestScore">RECORD: 0</div>
        <button class="restart" id="restartBtn">Rigioca</button>
      </div>
    </div>
  </div>

  <div class="hint" id="hint">Tieni premuto per ‚Äúagganciare‚Äù la palla, trascina nella fascia alta e lascia per farla cadere!</div>

<script>
(() => {
  /* ==========================
     CONFIGURAZIONE
  ========================== */
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // Sfondo erboso
  const grass = document.createElement('canvas');
  grass.width = grass.height = 128;
  const gctx = grass.getContext('2d');
  gctx.fillStyle = '#1a4d2a';
  gctx.fillRect(0, 0, 128, 128);
  for (let i = 0; i < 200; i++) {
    gctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.06})`;
    gctx.fillRect(Math.random() * 128, Math.random() * 128, 1, 1);
  }
  for (let i = 0; i < 40; i++) {
    gctx.strokeStyle = `rgba(255,255,255,${Math.random() * 0.1})`;
    gctx.lineWidth = 0.5;
    gctx.beginPath();
    gctx.moveTo(0, i * 3 + Math.random() * 2);
    gctx.lineTo(128, i * 3 + Math.random() * 2);
    gctx.stroke();
  }
  const grassPat = ctx.createPattern(grass, 'repeat');

  // Tipi di palle
  const TYPES = [
    'golf','pingpong','squash','lacrosse','tennis','baseball','cricket','pallamano','pallavolo','basket','waterpolo','calcio','pallamedica',
    'bomba', 'vetro', 'vortice', 'detonatrice', 'metal', 'oro'
  ];
  const SCORE_STEP = [10,20,40,80,120,180,260,360,520,700,900,1000];
  const RADII = {
    golf:18, pingpong:20, squash:22, lacrosse:24, tennis:26, baseball:28, cricket:30, pallamano:32, pallavolo:36, basket:40, waterpolo:42, calcio:44, pallamedica:50,
    bomba: 30, vetro: 28, vortice: 32, detonatrice: 28, metal: 26, oro: 26
  };
  const MASSE = {
    golf:0.046, pingpong:0.0027, squash:0.024, lacrosse:0.145, tennis:0.058, baseball:0.145, cricket:0.163, pallamano:0.475, pallavolo:0.27, basket:0.62, waterpolo:0.45, calcio:0.43, pallamedica:3.0,
    bomba: 0.8, vetro: 0.1, vortice: 0.3, detonatrice: 0.2, metal: 0.6, oro: 0.5
  };
  const REST = {
    golf:.75, pingpong:.88, squash:.7, lacrosse:.65, tennis:.8, baseball:.55, cricket:.55, pallamano:.5, pallavolo:.65, basket:.75, waterpolo:.6, calcio:.72, pallamedica:.35,
    bomba: 0.4, vetro: 0.9, vortice: 0.6, detonatrice: 0.7, metal: 0.3, oro: 0.2
  };
  const FRICTION = 0.004;
  const MERGE_SPEED_THRESHOLD = 100;

class Ball {
  constructor(x, y, type, sprite) {
    this.id = Math.random().toString(36).slice(2);
    this.x = x;
    this.y = y;
    this.type = type;
    this.r = RADII[type];
    this.m = MASSE[type];
    this.rest = REST[type];
    this.sprite = sprite;
    this.vx = 0;
    this.vy = 0;
    this.ax = 0;
    this.ay = 0;
    this.held = false;
    this.asleep = false;
    this.squash = 0;
    this.merging = false;
  }
}

  // Meccaniche di livello
  let level = 1;
  const LEVEL_THRESHOLD = 500;
  const BASE_G = 1200;
  let G = BASE_G;
  const BASE_DANGER_HEIGHT = 120;
  let gameOverY = BASE_DANGER_HEIGHT;

  // Fascia alta per il posizionamento
  const TOP_BAND_HEIGHT = 120;
  let spawnY = Math.min(60, TOP_BAND_HEIGHT / 2);

  // Palle speciali
  const SPECIAL_TYPES = new Set(['bomba', 'vetro', 'vortice', 'detonatrice', 'metal', 'oro']);
  const SPECIAL_CHANCE = 0.1;

  // Limiti
  const MAX_BALLS = 30;
  const MAX_PARTICLES = 100;
  const DROP_COOLDOWN = 0.4;
  let lastDropTime = 0;

  // Stato globale
  let balls = [];
  let paused = false;
  let gameOver = false;
  let score = 0;
  let bestScore = parseInt(localStorage.getItem('ballDropBest') || '0');
  let highestTypeIndex = 0;
  let vortexEffect = null;

  // üíé Potenziamenti
  let hasJolly = false;
  let hasFuoco = false;
  let heldPowerup = null;

  const R = (a, b) => a + Math.random() * (b - a);

  // Funzione helper per esagono (calcio)
  function drawHex(cx, x, y, size) {
    cx.save();
    cx.translate(x, y);
    cx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = (i * Math.PI) / 3;
      const xx = Math.cos(angle) * size;
      const yy = Math.sin(angle) * size;
      if (i === 0) cx.moveTo(xx, yy);
      else cx.lineTo(xx, yy);
    }
    cx.closePath();
    cx.fill();
    cx.restore();
  }

  // Cache sprite
  const spriteCache = new Map();
  const imagePromises = [];

function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
    img.src = src;
  });
}

// UI ELEMENTS
const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');
const finalScoreEl = document.getElementById('finalScore');
const bestScoreEl = document.getElementById('bestScore');
const nextIcon = document.getElementById('nextIcon');
const nextCtx = nextIcon.getContext('2d');
const pauseBtn = document.getElementById('pauseBtn');
const inventoryBtn = document.getElementById('inventoryBtn');
const overEl = document.getElementById('gameOver');
const restartBtn = document.getElementById('restartBtn');
const hintEl = document.getElementById('hint');
const jollyEl = document.getElementById('jolly');
const fuocoEl = document.getElementById('fuoco');

// MENU ELEMENTS
const menuOverlay = document.getElementById('menu-overlay');
const screenMain = document.getElementById('screen-main');
const screenOptions = document.getElementById('screen-options');
const screenCredits = document.getElementById('screen-credits');
const btnPlay = document.getElementById('btnPlay');
const btnOptions = document.getElementById('btnOptions');
const btnCredits = document.getElementById('btnCredits');
const btnBackOptions = document.getElementById('btnBackOptions');
const btnBackCredits = document.getElementById('btnBackCredits');
const btnToggleAudio = document.getElementById('btnToggleAudio');
const btnEnableCheats = document.getElementById('btnEnableCheats');

// PAUSE MENU ELEMENTS
const pauseMenu = document.getElementById('pauseMenu');
const btnResume = document.getElementById('btnResume');
const btnRestartPause = document.getElementById('btnRestartPause');
const btnOptionsPause = document.getElementById('btnOptionsPause');
const btnQuit = document.getElementById('btnQuit');
const btnClosePause = document.getElementById('btnClosePause');

// JOLLY SELECTOR ELEMENTS
const jollySelector = document.getElementById('jollySelector');
const btnPrev = document.getElementById('btnPrev');
const btnNext = document.getElementById('btnNext');
const previewName = document.getElementById('previewName');
const previewCanvas = document.getElementById('previewCanvas');
const btnSelectJolly = document.getElementById('btnSelectJolly');
const previewCtx = previewCanvas.getContext('2d');

// JOLLY SELECTABLE TYPES
const jollySelectableTypes = [
  'golf', 'pingpong', 'squash', 'tennis', 'basket', 'calcio', 'pallamedica',
  'bomba', 'vetro', 'vortice', 'detonatrice', 'metal', 'oro'
];
let jollySelectionIndex = 0;

function updateJollyPreview() {
  const type = jollySelectableTypes[jollySelectionIndex];
  previewName.textContent = type.charAt(0).toUpperCase() + type.slice(1);
  getSprite(type).then(sprite => {
    if (!sprite) return;
    previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
    const size = Math.min(previewCanvas.width, previewCanvas.height) * 0.8;
    const x = (previewCanvas.width - size) / 2;
    const y = (previewCanvas.height - size) / 2;
    previewCtx.imageSmoothingEnabled = false;
    previewCtx.drawImage(sprite, x, y, size, size);
  }).catch(()=>{});
}

btnPrev.addEventListener('click', () => {
  jollySelectionIndex = (jollySelectionIndex - 1 + jollySelectableTypes.length) % jollySelectableTypes.length;
  updateJollyPreview();
});

btnNext.addEventListener('click', () => {
  jollySelectionIndex = (jollySelectionIndex + 1) % jollySelectableTypes.length;
  updateJollyPreview();
});

btnSelectJolly.addEventListener('click', () => {
  const type = jollySelectableTypes[jollySelectionIndex];
  spawnBall(W/2, spawnY, type).then(ball => {
    if (!ball) return;
    ball.held = true;
    ball.asleep = false;
    heldBall = ball;
    setTimeout(() => {
      ball.held = false;
      heldBall = null;
      jollySelector.classList.remove('visible');
      jollySelector.classList.add('hidden');
      hasJolly = false;
      updatePowerupsUI();
    }, 50);
  }).catch(()=>{});
  jollySelectionIndex = 0;
});

// Funzione per avviare il gioco
function startGame() {
  menuOverlay.style.display = 'none';
  document.querySelector('.hud').classList.add('visible');
  balls = [];
  score = 0;
  level = 1;
  highestTypeIndex = 0;
  paused = false;
  gameOver = false;
  vortexEffect = null;
  hasJolly = false;
  hasFuoco = false;
  heldPowerup = null;
  scoreEl.textContent = fmt(0);
  levelEl.textContent = `LIVELLO ${level}`;
  updatePowerupsUI();
  redrawNext();
  for (let i = 0; i < 4; i++) {
    spawnBall(R(80, W - 80), R(100, 200), 'golf');
  }
  setTimeout(() => {
    hintEl.classList.add('show');
    setTimeout(() => hintEl.classList.remove('show'), 3000);
  }, 500);
  loop();
}

// Sposta typeToImage GLOBALE, fuori da getSprite
const typeToImage = {
  'basket': 'palla_da_basket.png',
  'golf': 'palla_da_golf.png',
  'pallamano': 'palla_da_pallamano.png',
  'tennis': 'palla_da_tennis.png',
  'pingpong': 'palla_da_pingpong.png',
  'squash': 'palla_da_squash.png',
  'lacrosse': 'palla_da_lacrosse.png',
  'baseball': 'palla_da_baseball.png',
  'cricket': 'palla_da_cricket.png',
  'pallavolo': 'palla_da_pallavolo.png',
  'waterpolo': 'palla_da_waterpolo.png',
  'calcio': 'palla_da_calcio.png',
  'pallamedica': 'pallamedica.png',
  'bomba': 'bomba.png',
  'vetro': 'palla_di_vetro.png',
  'vortice': 'palla_vortice.png',
  'detonatrice': 'detonatrice.png',
  'metal': 'metal.png',
  'oro': 'oro.png',
  'jolly': 'jolly.png',
  'fuoco': 'fuoco.png'
};

/**
 * Carica o recupera dal cache lo sprite per un tipo di palla
 * @param {string} type - Tipo di palla (es. 'golf', 'bomba')
 * @returns {HTMLCanvasElement|null} Canvas con l'immagine ridimensionata
 */
async function getSprite(type) {
    if (spriteCache.has(type)) {
        return spriteCache.get(type);
    }
    let sprite = null;
    const imgPath = typeToImage[type];
    if (!imgPath) {
        console.warn(`[getSprite] Tipo sconosciuto: '${type}'`);
    } else {
        try {
            const fullPath = `assets/sprite/${imgPath}`;
            const img = await loadImage(fullPath);
            const r = RADII[type];
            const scale = 1.5;
            const sizePx = Math.ceil(r * 2 * DPR * scale);
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = sizePx;
            const ctx = canvas.getContext('2d');
            const drawSize = r * 2 * DPR * scale;
            const offset = (sizePx - drawSize) / 2;
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, offset, offset, drawSize, drawSize);
            sprite = canvas;
        } catch (err) {
            console.error(`Errore caricamento sprite per ${type}:`, err);
        }
    }
    if (!sprite) {
        console.error(`[Asset Mancante] '${type}' non caricato.`);
        const r = RADII[type] || 24;
        const scale = 1.5;
        const sizePx = Math.ceil(r * 2 * DPR * scale);
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = sizePx;
        const ctx = canvas.getContext('2d');
        const center = sizePx / 2;
        const radius = r * DPR * scale;
        ctx.translate(center, center);
        ctx.fillStyle = '#d32f2f';
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(-radius * 0.7, -radius * 0.7);
        ctx.lineTo(radius * 0.7, radius * 0.7);
        ctx.moveTo(-radius * 0.7, radius * 0.7);
        ctx.lineTo(radius * 0.7, -radius * 0.7);
        ctx.stroke();
        sprite = canvas;
    }
    spriteCache.set(type, sprite);
    return sprite;
}

// Pre-carica tutti gli sprite
let spritesLoaded = false;
(async () => {
  try {
    await Promise.all(TYPES.map(type => getSprite(type)));
    console.log('‚úÖ Tutti gli sprite sono stati caricati con successo.');
    spritesLoaded = true;
  } catch (err) {
    console.warn('‚ö†Ô∏è Alcuni sprite potrebbero non essere stati caricati:', err);
    spritesLoaded = true;
  }
})();

// MENU NAVIGATION
btnPlay.addEventListener('click', () => {
  if (!spritesLoaded) {
    floatText('Caricamento...', W/2, H/2);
    return;
  }
  startGame();
});

btnOptions.addEventListener('click', () => {
  screenMain.classList.remove('active');
  screenOptions.classList.add('active');
});

btnCredits.addEventListener('click', () => {
  screenMain.classList.remove('active');
  screenCredits.classList.add('active');
});

btnBackOptions.addEventListener('click', () => {
  screenOptions.classList.remove('active');
  screenMain.classList.add('active');
});

btnBackCredits.addEventListener('click', () => {
  screenCredits.classList.remove('active');
  screenMain.classList.add('active');
});

// AUDIO TOGGLE
let audioEnabled = true;
btnToggleAudio.addEventListener('click', () => {
  audioEnabled = !audioEnabled;
  musicPlaying = audioEnabled;
  btnToggleAudio.textContent = audioEnabled ? 'üîä ON' : 'üîá OFF';
  btnToggleAudio.classList.toggle('off', !audioEnabled);
});

// CHEATS TOGGLE
let cheatsEnabled = false;
btnEnableCheats.addEventListener('click', () => {
  if (!cheatsEnabled) {
    enableCheats();
    btnEnableCheats.textContent = 'ON';
    btnEnableCheats.style.background = '#4caf50';
    cheatsEnabled = true;
    floatText('TRUCCHI ATTIVATI!', W/2, H/2);
    sfx('powerup');
  }
});

function fmt(n) { return 'PUNTEGGIO ' + String(n).padStart(6, '0'); }

function updatePowerupsUI() {
  jollyEl.style.display = hasJolly ? 'flex' : 'none';
  fuocoEl.style.display = hasFuoco ? 'flex' : 'none';
  inventoryBtn.style.display = (hasJolly || hasFuoco) ? 'grid' : 'none';
}

function addScore(n, x, y) {
  score += n;
  scoreEl.textContent = fmt(score);
  scoreEl.classList.add('highlight');
  setTimeout(() => scoreEl.classList.remove('highlight'), 300);
  floatText(`+${n}`, x, y);
  const newLevel = Math.floor(score / LEVEL_THRESHOLD) + 1;
  if (newLevel > level) {
    level = newLevel;
    onLevelUp();
  }
}

function onLevelUp() {
  for (const b of balls) {
    b.rest = Math.max(0.25, REST[b.type] - (level - 1) * 0.05);
  }
  floatText(`LIVELLO ${level}!`, W / 2, H / 2);
  levelEl.textContent = `LIVELLO ${level}`;
  sfx('boing');
  ctx.filter = 'blur(2px)';
  setTimeout(() => ctx.filter = 'none', 100);
}

// Particelle
let particles = [];
function spawnStars(x, y) {
  for (let i = 0; i < 12; i++) {
    const size = R(2, 5) * DPR;
    particles.push({
      x, y,
      vx: R(-120, 120),
      vy: R(-180, -60),
      life: R(0.6, 1.0),
      t: 0,
      color: ['#ffd700', '#ffaa00', '#ffffff'][Math.floor(R(0, 3))],
      size,
      rotation: R(0, Math.PI * 2),
      type: 'star'
    });
  }
}

function floatText(t, x, y) {
  particles.push({
    text: t,
    x, y,
    vx: R(-20, 20),
    vy: -60,
    life: 1.0,
    t: 0,
    color: '#ffdd00',
    size: 20
  });
}

// Audio
let AudioContext = window.AudioContext || window.webkitAudioContext;
let Audio = null;
let musicPlaying = true;

function initAudio() {
  if (!Audio) {
    Audio = new AudioContext();
  }
}

function sfx(kind) {
  if (!musicPlaying || !Audio) return;
  try {
    const g = Audio.createGain();
    g.connect(Audio.destination);
    g.gain.value = 0.15;
    const o = Audio.createOscillator();
    o.connect(g);
    const now = Audio.currentTime;
    switch (kind) {
      case 'tink': o.type = 'sine'; o.frequency.setValueAtTime(700, now); o.frequency.exponentialRampToValueAtTime(500, now + 0.1); break;
      case 'boing': o.type = 'triangle'; o.frequency.setValueAtTime(200, now); o.frequency.exponentialRampToValueAtTime(150, now + 0.15); break;
      case 'merge': o.type = 'sawtooth'; o.frequency.setValueAtTime(400, now); o.frequency.exponentialRampToValueAtTime(250, now + 0.2); break;
      case 'powerup': o.type = 'square'; o.frequency.setValueAtTime(800, now); o.frequency.exponentialRampToValueAtTime(600, now + 0.15); break;
    }
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.3, now + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
    o.start(now);
    o.stop(now + 0.26);
  } catch (e) {}
}

// Attiva audio al primo tocco
document.addEventListener('touchstart', initAudio, { once: true });
document.addEventListener('click', initAudio, { once: true });

// üîÅ SISTEMA DI DROP CON ANTI-SPAM
let heldBall = null;
let isDragging = false;
let currentPointerId = null;

canvas.addEventListener('pointerdown', (e) => {
    if (gameOver || paused || isDragging) return;
    const now = performance.now() / 1000;
    if (now - lastDropTime < DROP_COOLDOWN) {
        floatText('Aspetta!', W / 2, H / 2);
        sfx('tink');
        return;
    }
    const rect = canvas.getBoundingClientRect();
    let x = (e.clientX - rect.left) / rect.width * W;
    if (x < 10 || x > W - 10) return;
    let type;
    if (level >= 5 && Math.random() < SPECIAL_CHANCE) {
        const choices = ['bomba', 'vetro', 'vortice', 'detonatrice'];
        if (level >= 7 && Math.random() < 0.3) choices.push('metal');
        if (level >= 10 && Math.random() < 0.1) choices.push('oro');
        type = choices[Math.floor(Math.random() * choices.length)];
    } else {
        type = TYPES[Math.floor(R(0, Math.min(highestTypeIndex + 1, 5)))];
    }
    if (balls.length >= MAX_BALLS) return;
    spawnBall(x, spawnY, type).then(ball => {
        if (!ball) return;
        heldBall = ball;
        heldBall.vx = 0;
        heldBall.vy = 0;
        heldBall.held = true;
        heldBall.asleep = false;
        isDragging = true;
        currentPointerId = e.pointerId;
        e.preventDefault();
        canvas.setPointerCapture(e.pointerId);
        floatText('PRONTO', x, spawnY - 20);
        sfx('tink');
        lastDropTime = now;
    }).catch(()=>{});
});

canvas.addEventListener('pointermove', (e) => {
    if (!isDragging || !heldBall || e.pointerId !== currentPointerId) return;
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const newX = (e.clientX - rect.left) / rect.width * W;
    const minX = 10 + heldBall.r;
    const maxX = W - 10 - heldBall.r;
    heldBall.x = Math.max(minX, Math.min(maxX, newX));
    heldBall.y = spawnY;
});

canvas.addEventListener('pointerup', (e) => {
    if (!isDragging || !heldBall || e.pointerId !== currentPointerId) return;
    heldBall.held = false;
    heldBall.asleep = false;
    isDragging = false;
    heldBall = null;
    try {
        canvas.releasePointerCapture(currentPointerId);
    } catch (e) {}
    currentPointerId = null;
});

canvas.addEventListener('pointercancel', (e) => {
    if (!isDragging || !heldBall || e.pointerId !== currentPointerId) return;
    heldBall.held = false;
    heldBall.asleep = false;
    isDragging = false;
    heldBall = null;
    try {
        canvas.releasePointerCapture(currentPointerId);
    } catch (e) {}
    currentPointerId = null;
});

// === NUOVO: GESTIONE MENU PAUSA ===
pauseBtn.addEventListener('click', () => {
  if (gameOver) return;
  paused = !paused;
  pauseBtn.style.opacity = paused ? 0.6 : 1;
  if (paused) {
    sfx('boing');
    pauseMenu.classList.remove('hidden');
    pauseMenu.classList.add('visible');
  } else {
    pauseMenu.classList.remove('visible');
    pauseMenu.classList.add('hidden');
  }
});

// PULSANTI MENU PAUSA
btnResume.addEventListener('click', () => {
  paused = false;
  pauseBtn.style.opacity = 1;
  pauseMenu.classList.remove('visible');
  pauseMenu.classList.add('hidden');
});

btnRestartPause.addEventListener('click', () => {
  pauseMenu.classList.remove('visible');
  pauseMenu.classList.add('hidden');
  resetGame();
});

btnOptionsPause.addEventListener('click', () => {
  pauseMenu.classList.remove('visible');
  pauseMenu.classList.add('hidden');
  screenMain.classList.remove('active');
  screenOptions.classList.add('active');
});

btnQuit.addEventListener('click', () => {
  pauseMenu.classList.remove('visible');
  pauseMenu.classList.add('hidden');
  menuOverlay.style.display = 'flex';
  document.querySelector('.hud').classList.remove('visible');
  resetGame();
});

btnClosePause.addEventListener('click', () => {
  paused = false;
  pauseBtn.style.opacity = 1;
  pauseMenu.classList.remove('visible');
  pauseMenu.classList.add('hidden');
});

inventoryBtn.addEventListener('click', () => {
  if (hasFuoco) {
    floatText('FUOCO!', W / 2, H / 2);
    sfx('powerup');
    for (const b of balls) {
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: b.x, y: b.y,
          vx: R(-100, 100), vy: R(-150, 150),
          life: R(0.3, 0.7), t: 0,
          color: '#ff4500', size: R(2, 4)
        });
      }
    }
    balls = [];
    hasFuoco = false;
  } else if (hasJolly) {
    jollySelector.classList.remove('hidden');
    jollySelector.classList.add('visible');
    updateJollyPreview();
    floatText('JOLLY: Seleziona una palla', W / 2, H / 2);
    sfx('powerup');
  }
  updatePowerupsUI();
});

restartBtn.addEventListener('click', resetGame);

// Reset pulito
function resetGame() {
  balls = [];
  particles = [];
  score = 0;
  level = 1;
  highestTypeIndex = 0;
  paused = false;
  gameOver = false;
  vortexEffect = null;
  hasJolly = false;
  hasFuoco = false;
  heldPowerup = null;
  jollySelector.classList.remove('visible');
  jollySelector.classList.add('hidden');
  scoreEl.textContent = fmt(0);
  levelEl.textContent = `LIVELLO ${level}`;
  updatePowerupsUI();
  redrawNext();
  for (let i = 0; i < 4; i++) {
    spawnBall(R(80, W - 80), R(100, 200), 'golf');
  }
  overEl.classList.remove('visible');
  setTimeout(() => overEl.classList.add('hidden'), 300);
}

async function spawnBall(x, y, type) {
  if (!type) return null;
  const r = RADII[type];
  let sprite = null;
  if (spriteCache.has(type)) {
    sprite = spriteCache.get(type);
  } else {
    const imgPath = `assets/sprite/${typeToImage[type]}`;
    try {
      const img = await loadImage(imgPath);
      const s = Math.ceil(r * 2 * DPR + 10);
      const c = document.createElement('canvas');
      c.width = c.height = s;
      const cx = c.getContext('2d');
      const size = r * 2 * DPR;
      cx.drawImage(img, (s - size) / 2, (s - size) / 2, size, size);
      sprite = c;
      spriteCache.set(type, sprite);
    } catch (err) {
      console.warn('Impossibile caricare immagine:', imgPath, err);
      sprite = await getSprite(type);
    }
  }
  const ball = new Ball(x, y, type, sprite);
  balls.push(ball);
  return ball;
}

async function redrawNext() {
    nextCtx.clearRect(0, 0, nextIcon.width, nextIcon.height);
    const idx = Math.min(highestTypeIndex + 1, TYPES.length - 1);
    const type = TYPES[idx];
    const s = await getSprite(type);
    if (!s) {
        console.error(`Sprite non trovato per il tipo: ${type}`);
        return;
    }
    const sz = 48 * DPR;
    const x = (nextIcon.width - sz) / 2;
    const y = (nextIcon.height - sz) / 2;
    nextCtx.imageSmoothingEnabled = false;
    nextCtx.drawImage(s, x, y, sz, sz);
}

// üî• Bomba
function explode(x, y) {
  sfx('boing');
  floatText('BOOM!', x, y);
  for (let i = 0; i < 20; i++) {
      particles.push({
          x, y,
          vx: R(-200, 200),
          vy: R(-250, -60),
          life: R(0.5, 0.9),
          t: 0,
          color: ['#ff4500', '#ff8c00', '#ffd700'][Math.floor(R(0, 3))],
          size: R(3, 6) * DPR
      });
  }
  const survivors = [];
  for (const b of balls) {
      const dist = Math.hypot(b.x - x, b.y - y);
      if (dist < 80) {
          if (b.type === 'metal') {
              hasJolly = true;
              floatText('JOLLY!', b.x, b.y);
              sfx('powerup');
          } else if (b.type === 'oro') {
              addScore(500, b.x, b.y);
              if (Math.random() < 0.7) {
                  hasJolly = true;
                  floatText('JOLLY!', b.x, b.y);
              } else {
                  hasFuoco = true;
                  floatText('FUOCO!', b.x, b.y);
              }
              sfx('powerup');
          }
      } else {
          survivors.push(b);
      }
  }
  balls = survivors;
  updatePowerupsUI();
}

function checkCrush() {
  for (const top of balls) {
    if (top.asleep && !top.held) {
      for (const bottom of balls) {
        if (bottom.asleep || bottom.type === 'vetro' || bottom.held) continue;
        if (top === bottom) continue;
        const dy = bottom.y - top.y;
        const dx = Math.abs(bottom.x - top.x);
        if (dy > 0 && dy < 30 && dx < (top.r + bottom.r) * 0.6 && top.r > bottom.r + 8) {
          floatText('CRUSH!', bottom.x, bottom.y);
          balls = balls.filter(b => b !== bottom);
          sfx('boing');
          return;
        }
      }
    }
  }
}
function detonateAllBombs() {
  balls = balls.filter(ball => ball.type !== 'bomba');
}

function update(dt) {
    if (paused || gameOver) return;
    G = BASE_G + (level - 1) * 100;
    gameOverY = Math.min(300, BASE_DANGER_HEIGHT + (level - 1) * 10);
    for (const b of balls) {
        if (b.asleep || b.held) continue;
        b.vy += G * dt;
        b.vx *= (1 - FRICTION);
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        if (b.x - b.r < 10) {
            b.x = 10 + b.r;
            b.vx = -b.vx * b.rest * 0.8;
        }
        if (b.x + b.r > W - 10) {
            b.x = W - 10 - b.r;
            b.vx = -b.vx * b.rest * 0.8;
        }
        if (b.y + b.r > H - 10) {
            b.y = H - 10 - b.r;
            if (b.type === 'vetro') {
                let isSupported = false;
                for (const other of balls) {
                    if (other === b || other.held) continue;
                    if (other.y > b.y && Math.abs(b.x - other.x) < (b.r + other.r) * 0.8) {
                        const gap = (b.y + b.r) - (other.y - other.r);
                        if (gap < 5) {
                            isSupported = true;
                            break;
                        }
                    }
                }
                if (!isSupported) {
                    floatText('SPLASH!', b.x, b.y);
                    sfx('tink');
                    balls = balls.filter(ball => ball !== b);
                    continue;
                }
            }
            const effectiveRest = Math.max(0.2, b.rest - (level - 1) * 0.04);
            b.vy = -Math.abs(b.vy) * effectiveRest;
            if (Math.abs(b.vy) < 15) b.vy = 0;
            if (Math.abs(b.vx) < 20) b.vx *= 0.95;
            if (Math.abs(b.vy) < 10 && Math.abs(b.vx) < 8) b.asleep = true;
        }
    }
    if (vortexEffect) {
        vortexEffect.duration -= dt;
        if (vortexEffect.duration <= 0) {
            vortexEffect = null;
        } else {
            for (const b of balls) {
                if (b.type === 'vortice' || b.held) continue;
                const dx = vortexEffect.x - b.x;
                const dy = vortexEffect.y - b.y;
                const dist = Math.hypot(dx, dy);
                if (dist < 120) {
                    const force = (120 - dist) / 120 * 400 * dt;
                    b.vx += (dx / dist) * force;
                    b.vy += (dy / dist) * force;
                }
            }
        }
    }
    const cell = 64;
    const grid = new Map();
    function key(i, j) { return `${i},${j}`; }
    for (const b of balls) {
        if (b.held) continue;
        const i = Math.floor(b.x / cell), j = Math.floor(b.y / cell);
        for (let ii = i - 1; ii <= i + 1; ii++) {
            for (let jj = j - 1; jj <= j + 1; jj++) {
                const k = key(ii, jj);
                if (!grid.has(k)) grid.set(k, []);
                grid.get(k).push(b);
            }
        }
    }
    const pairs = new Set();
    for (const arr of grid.values()) {
        for (let a = 0; a < arr.length; a++) {
            for (let d = a + 1; d < arr.length; d++) {
                const A = arr[a], B = arr[d];
                const id = A.id < B.id ? A.id + '|' + B.id : B.id + '|' + A.id;
                if (pairs.has(id)) continue;
                pairs.add(id);
                const dx = B.x - A.x, dy = B.y - A.y;
                const dist2 = dx * dx + dy * dy;
                const rr = A.r + B.r;
                if (dist2 > rr * rr) continue;
                const dist = Math.sqrt(dist2) || 1;
                const nx = dx / dist, ny = dy / dist;
                const overlap = rr - dist;
                const totalMass = A.m + B.m;
                const aShare = B.m / totalMass, bShare = A.m / totalMass;
                A.x -= nx * overlap * aShare;
                A.y -= ny * overlap * aShare;
                B.x += nx * overlap * bShare;
                B.y += ny * overlap * bShare;
                const rvx = B.vx - A.vx, rvy = B.vy - A.vy;
                const velAlongNormal = rvx * nx + rvy * ny;
                if (velAlongNormal < 0) {
                    const e = Math.min(A.rest, B.rest) * 1.1;
                    const j = -(1 + e) * velAlongNormal / (1 / A.m + 1 / B.m);
                    const impX = j * nx, impY = j * ny;
                    A.vx -= impX / A.m;
                    A.vy -= impY / A.m;
                    B.vx += impX / B.m;
                    B.vy += impY / B.m;
                    A.squash = B.squash = Math.min(1.5, Math.abs(velAlongNormal) / 400);
                    A.asleep = B.asleep = false;
                }
                if (A.type === B.type && !A.merging && !B.merging && Math.hypot(rvx, rvy) < MERGE_SPEED_THRESHOLD && A.held === B.held) {
                    if (A.type === 'bomba') {
                        explode((A.x + B.x) / 2, (A.y + B.y) / 2);
                        balls = balls.filter(b => b !== A && b !== B);
                    } else if (A.type === 'detonatrice') {
                        detonateAllBombs();
                        balls = balls.filter(b => b !== A && b !== B);
                    } else if (A.type === 'metal' || A.type === 'oro') {
                    } else {
                        mergeBalls(A, B);
                    }
                }
            }
        }
    }
    for (const b of balls) {
        if (b.asleep && !b.held && b.y - b.r < gameOverY) {
            endGame();
            return;
        }
    }
    checkCrush();
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.t += dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 600 * dt;
        if (p.type === 'star') p.rotation += 0.2;
        if (p.t > p.life) particles.splice(i, 1);
        if (particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);
    }
}

function endGame() {
  if (gameOver) return;
  gameOver = true;
  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('ballDropBest', bestScore);
  }
  finalScoreEl.textContent = `PUNTEGGIO: ${score}`;
  bestScoreEl.textContent = `RECORD: ${bestScore}`;
  overEl.classList.remove('hidden');
  setTimeout(() => overEl.classList.add('visible'), 100);
}

function mergeBalls(A, B) {
  sfx('merge');
  spawnStars((A.x + B.x) / 2, (A.y + B.y) / 2);
  const baseType = A.type;
  const idx = TYPES.indexOf(baseType);
  const scoreBonus = (A.type === 'vetro' || B.type === 'vetro') ? 3 : 1;
  if (idx < SCORE_STEP.length) {
    addScore(SCORE_STEP[idx] * scoreBonus, (A.x + B.x) / 2, (A.y + B.y) / 2);
  }
  A.merging = B.merging = true;
  const totalMass = A.m + B.m;
  const x = (A.x * A.m + B.x * B.m) / totalMass;
  const y = (A.y * A.m + B.y * B.m) / totalMass;
  const vx = (A.vx * A.m + B.vx * B.m) / totalMass;
  const vy = (A.vy * A.m + B.vy * B.m) / totalMass;
  balls = balls.filter(b => b !== A && b !== B);
  const nextIdx = Math.min(idx + 1, TYPES.length - 1);
  const newType = TYPES[nextIdx];
  const C = {
    id: Math.random().toString(36).slice(2),
    type: newType,
    x, y, vx, vy,
    r: RADII[newType],
    m: MASSE[newType],
    rest: REST[newType],
    squash: 0,
    merging: false,
    asleep: false,
    held: false
  };
  balls.push(C);
  if (!SPECIAL_TYPES.has(newType)) {
    highestTypeIndex = Math.max(highestTypeIndex, nextIdx);
  }
  redrawNext();
  if (newType === 'vortice') {
    vortexEffect = { x: C.x, y: C.y, duration: 2.0 };
    floatText('VORTICE!', C.x, C.y - 40);
    sfx('tink');
  }
}

const CHEAT_CODES = {
  "BALLDROP": () => { enableCheats(); },
  "GODMODE": () => {
    score = 999999;
    level = 99;
    hasJolly = true;
    hasFuoco = true;
    updatePowerupsUI();
    levelEl.textContent = `LIVELLO ${level}`;
    scoreEl.textContent = fmt(score);
    floatText('GOD MODE!', W/2, H/2);
    sfx('powerup');
  },
  "SPAWNGOLF": () => spawnBall(W/2, spawnY, 'golf'),
  "SPAWNBASKET": () => spawnBall(W/2, spawnY, 'basket'),
  "SPAWNORO": () => spawnBall(W/2, spawnY, 'oro'),
  "ADD10K": () => addScore(10000, W/2, 50),
  "CLEAR": () => { balls = []; floatText('CAMPO LIBERO!', W/2, H/2); },
  "VORTEX": () => {
    vortexEffect = { x: W/2, y: H/2, duration: 5.0 };
    floatText('VORTICE MANUALE!', W/2, H/2 - 40);
  }
};

let cheatBuffer = "";
function enableCheats() {
  window.cheats = {
    addScore: (n) => addScore(n, W/2, 50),
    setLevel: (l) => {
      level = l;
      levelEl.textContent = `LIVELLO ${level}`;
      onLevelUp();
    },
    spawn: (type) => spawnBall(W/2, spawnY, type),
    giveJolly: () => { hasJolly = true; updatePowerupsUI(); floatText('JOLLY!', W/2, 50); },
    giveFuoco: () => { hasFuoco = true; updatePowerupsUI(); floatText('FUOCO!', W/2, 50); },
    godMode: () => CHEAT_CODES["GODMODE"](),
    clear: () => CHEAT_CODES["CLEAR"]()
  };
  console.log("%cüéÆ TRUCCHI ATTIVATI! Comandi disponibili:", "color: #ffdd00; font-weight: bold");
  console.log(`- cheats.addScore(1000)`);
  console.log(`- cheats.setLevel(10)`);
  console.log(`- cheats.spawn('oro')`);
  console.log(`- cheats.giveJolly()`);
  console.log(`- cheats.godMode()`);
  console.log(`- cheats.clear()`);
}

document.addEventListener('keydown', (e) => {
  if (gameOver) return;
  cheatBuffer += e.key.toUpperCase();
  if (cheatBuffer.length > 10) {
    cheatBuffer = cheatBuffer.slice(-10);
  }
  for (const [code, action] of Object.entries(CHEAT_CODES)) {
    if (cheatBuffer.endsWith(code)) {
      cheatBuffer = "";
      action();
      break;
    }
  }
});

function draw() {
  ctx.save();
  ctx.fillStyle = grassPat;
  ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
  ctx.fillRect(0, 0, W, gameOverY);
  ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, gameOverY);
  ctx.lineTo(W, gameOverY);
  ctx.stroke();
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 2;
  ctx.strokeRect(8, 8, W - 16, H - 16);
  ctx.restore();
  const sortedBalls = [...balls].sort((a, b) => a.y - b.y);
  for (const b of sortedBalls) {
    const sprite = spriteCache.get(b.type);
    if (!sprite) {
      console.warn(`[draw] Sprite non trovato per '${b.type}', saltato`);
      continue;
    }
    const sx = sprite.width / 2;
    const sy = sprite.height / 2;
    const squish = 1 - Math.min(0.3, b.squash * 0.3);
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.scale(1 / squish, squish);
    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetY = 4;
    ctx.drawImage(sprite, -sx, -sy, sprite.width, sprite.height);
    ctx.restore();
    b.squash *= 0.7;
  }
  if (vortexEffect) {
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.strokeStyle = '#7b68ee';
    ctx.lineWidth = 3;
    for (let i = 0; i < 3; i++) {
      const radius = 40 + i * 20;
      ctx.beginPath();
      ctx.arc(vortexEffect.x, vortexEffect.y, radius, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.restore();
  }
  ctx.save();
  for (const p of particles) {
    const alpha = 1 - p.t / p.life;
    if (alpha <= 0) continue;
    ctx.globalAlpha = alpha;
    if (p.text) {
      ctx.font = `bold ${p.size}px sans-serif`;
      ctx.fillStyle = p.color;
      ctx.textAlign = 'center';
      ctx.fillText(p.text, p.x, p.y);
    } else {
      ctx.save();
      ctx.translate(p.x, p.y);
      if (p.rotation !== undefined) ctx.rotate(p.rotation);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
      ctx.restore();
    }
  }
  ctx.restore();
  ctx.globalAlpha = 1;
}

let acc = 0;
let last = performance.now();
const dtFixed = 1 / 120;
function loop() {
  const now = performance.now();
  let dt = (now - last) / 1000;
  last = now;
  if (dt > 0.2) dt = 0.1;
  acc += dt;
  while (acc >= dtFixed && !paused && !gameOver) {
    update(dtFixed);
    acc -= dtFixed;
  }
  draw();
  requestAnimationFrame(loop);
}

loop();
})();
</script>
</body>
</html>
