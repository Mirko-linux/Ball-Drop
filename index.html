<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Ball Drop</title>
  <style>
    html, body { 
      height: 100%; 
      margin: 0; 
      padding: 0; 
      background: #0a1f0f; 
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; 
      color: #e0ffe0;
      touch-action: manipulation;
      overflow: hidden;
    }
    body { 
      display: flex; 
      flex-direction: column; 
    }
    /* nasconde elementi con classe .hidden */
    .hidden { display: none !important; }

    /* === MISSIONI === */
#missionsOverlay {
  display: flex;
  justify-content: center;
  align-items: center;
  background: rgba(5, 30, 10, 0.9);
  backdrop-filter: blur(10px);
}

.missions-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  padding: 30px;
  border-radius: 20px;
  background: rgba(0, 0, 0, 0.7);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
  max-width: 90%;
  width: 400px;
}

.mission-item {
  width: 100%;
  padding: 15px;
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: #e0ffe0;
  text-align: left;
}

.mission-item.completed {
  background: rgba(40, 167, 69, 0.2);
  color: #a8ff80;
}

.mission-item.active {
  border-color: #a8ff80;
  box-shadow: 0 0 10px rgba(168, 255, 128, 0.3);
}

    /* === MENU SYSTEM === */
    #menu-overlay {
      position: fixed;
      inset: 0;
      background: rgba(5, 30, 10, 0.95);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      z-index: 100;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    .menu-screen {
      display: none;
      text-align: center;
      max-width: 400px;
      width: 90%;
    }
    .menu-screen.active {
      display: block;
    }
    .menu-title {
      font-size: 36px;
      font-weight: 900;
      color: #a8ff80;
      margin: 0 0 30px;
      text-shadow: 0 0 10px rgba(160, 255, 120, 0.5);
      letter-spacing: 1px;
    }
    .menu-btn {
      display: block;
      width: 100%;
      padding: 14px;
      margin: 12px 0;
      border: none;
      border-radius: 14px;
      background: rgba(100, 200, 100, 0.2);
      color: #e0ffe0;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    .menu-btn:hover {
      background: rgba(160, 255, 120, 0.3);
      transform: translateY(-2px);
    }
    .menu-back {
      margin-top: 25px;
      background: rgba(255, 255, 255, 0.1);
      font-size: 16px;
    }
    .credits-text {
      color: #c0e0c0;
      line-height: 1.6;
      margin: 20px 0;
      font-size: 14px;
    }
    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 15px 0;
      color: #d0f0d0;
      font-size: 15px;
    }
    .toggle-btn {
      padding: 8px 16px;
      border-radius: 10px;
      border: none;
      background: #4caf50;
      color: white;
      font-weight: bold;
      cursor: pointer;
    }
    .toggle-btn.off { background: #f44336; }
/* === TEMI === */
body.theme-fire { background: #2a0a0a; }
body.theme-night { background: #0a0a2a; }

.hud.theme-fire {
  background: rgba(42, 10, 10, 0.95);
  border-bottom-color: rgba(255, 100, 100, 0.2);
}
.hud.theme-night {
  background: rgba(10, 10, 42, 0.95);
  border-bottom-color: rgba(100, 100, 255, 0.2);
}

#game.theme-fire {
  background: #4a1a1a;
  border-color: rgba(255, 100, 100, 0.2);
}
#game.theme-night {
  background: #1a1a4a;
  border-color: rgba(100, 100, 255, 0.2);
}
    /* === HUD (nascosto all'avvio) === */
    .hud { 
      position: fixed; 
      top: 0; 
      left: 0; 
      right: 0; 
      height: 80px; 
      display: none;
      align-items: center; 
      justify-content: space-between;
      padding: 12px 16px; 
      box-sizing: border-box; 
      z-index: 10; 
      background: rgba(5, 30, 10, 0.95);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(100, 255, 100, 0.2);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    .hud.visible { display: flex; }
    .score { 
      font-weight: 900; 
      font-size: 22px; 
      color: #a8ff80; 
      letter-spacing: 1.5px; 
      text-shadow: 0 0 10px rgba(160, 255, 120, 0.5);
      transition: transform 0.2s ease;
    }
    .score.highlight {
      color: #ffdd00;
      text-shadow: 0 0 15px rgba(255, 220, 0, 0.8);
      transform: scale(1.1);
    }
    .info { 
      display: flex; 
      flex-direction: column; 
      align-items: flex-end; 
      gap: 2px; 
      font-size: 12px; 
      color: #c0e0c0;
      text-align: right;
    }
    .level { 
      font-weight: 700; 
      color: #ffd700; 
      background: rgba(255, 215, 0, 0.1); 
      padding: 2px 6px; 
      border-radius: 4px;
    }
    .next { 
      display: flex; 
      align-items: center; 
      gap: 10px; 
      color: #d0f0d0; 
      font-size: 14px; 
      font-weight: 600;
    }
    .next canvas { 
      width: 42px; 
      height: 42px; 
      image-rendering: pixelated; 
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
    }
    .btn { 
      width: 48px; 
      height: 48px; 
      display: grid; 
      place-items: center; 
      border-radius: 50%; 
      background: rgba(255, 255, 255, 0.1); 
      border: none; 
      color: white; 
      cursor: pointer; 
      margin-left: 10px;
      transition: all 0.2s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }
    .btn:hover { 
      background: rgba(255, 255, 255, 0.2); 
      transform: scale(1.05);
    }
    .powerups {
      display: flex;
      gap: 10px;
      font-size: 12px;
      color: #d0f0d0;
    }
    .powerup {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .powerup-icon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
    }
    .jolly-icon { background: #ffd700; border: 1px solid #ff9900; }
    .fuoco-icon { background: #ff4500; }
    #wrap { 
      position: relative; 
      flex: 1; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      padding: 80px 10px 10px;
      overflow: hidden;
    }
    #game { 
      width: 100%; 
      max-width: 480px; 
      height: 720px; 
      max-height: calc(100vh - 100px); 
      background: #1a4d2a; 
      border-radius: 16px; 
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), inset 0 0 0 1px rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(100, 200, 100, 0.2);
      touch-action: none;
      display: block;
    }
    .center { 
      position: absolute; 
      inset: 0; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      pointer-events: none; 
    }
    .overlay { 
      display: flex;
      flex-direction: column; 
      align-items: center; 
      gap: 20px; 
      color: white; 
      text-align: center; 
      padding: 30px;
      border-radius: 20px;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      max-width: 85%;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      pointer-events: auto;
      transform: scale(0.9);
      opacity: 0;
      transition: all 0.3s ease;
    }
    .overlay.visible {
      transform: scale(1);
      opacity: 1;
    }
    .title { 
      font-size: 32px; 
      font-weight: 900; 
      color: #ff5555;
      text-shadow: 0 3px 8px rgba(0,0,0,0.7);
    }
    .score-final {
      font-size: 20px;
      color: #aaffaa;
      font-weight: 700;
    }
    .restart { 
      padding: 16px 30px; 
      border-radius: 14px; 
      border: none; 
      font-weight: 700; 
      font-size: 18px; 
      cursor: pointer; 
      background: #e63946; 
      color: white; 
      box-shadow: 0 6px 16px rgba(230, 57, 70, 0.5);
      transition: all 0.2s ease;
    }
    .restart:hover { 
      background: #c1121f; 
      transform: translateY(-2px);
    }
    .hint { 
      position: fixed; 
      bottom: 16px; 
      left: 50%; 
      transform: translateX(-50%) translateY(20px);
      color: #c8ffd2; 
      font-size: 13px; 
      background: rgba(0, 0, 0, 0.6); 
      padding: 8px 16px; 
      border-radius: 12px; 
      z-index: 10;
      opacity: 0;
      transition: all 0.4s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      pointer-events: none;
    }
    .hint.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* === PAUSE MENU === */
/* --- Sostituisci il blocco #pauseMenu esistente con questo --- */
#pauseMenu {
  position: fixed;
  inset: 0; /* prende tutto lo schermo */
  display: flex;
  justify-content: center;
  align-items: center;

  /* sfondo leggermente trasparente + blur */
  background: rgba(5, 30, 10, 0.85);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);

  /* IMPORTANT: sopra gli altri overlay/hud */
  z-index: 260;

  /* inizialmente nascosto via opacity/pointer (non usando display:none
     cos√¨ le transizioni funzionano bene) */
  opacity: 0;
  pointer-events: none;
  transform: scale(0.98);
  transition: opacity 0.22s ease, transform 0.22s ease;
}

/* quando mostriamo il menu: diventa cliccabile e visibile */
#pauseMenu.visible {
  opacity: 1;
  pointer-events: auto;
  transform: scale(1);
}

/* quando √® nascosto (forza stato nascosto) */
#pauseMenu.hidden {
  opacity: 0;
  pointer-events: none;
  transform: scale(0.98);
}

    .pause-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      padding: 20px;
      border-radius: 16px;
      background: #4e342e;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      width: 80%;
      max-width: 300px;
      position: relative;
    }
    .pause-title {
      font-size: 28px;
      font-weight: 900;
      color: #ffeb3b;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      letter-spacing: 1px;
      margin: 0 0 15px;
    }
    .pause-btn {
      width: 100%;
      padding: 12px 20px;
      margin: 5px 0;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #ffca28, #ffb300);
      color: #4e342e;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 3px 6px rgba(0,0,0,0.2);
      text-transform: uppercase;
      font-size: 16px;
    }
    .pause-btn:hover {
      background: linear-gradient(135deg, #ffd54f, #ffc107);
      transform: translateY(-2px);
      box-shadow: 0 5px 10px rgba(0,0,0,0.3);
    }
    .pause-close {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #ff5722;
      color: white;
      font-size: 20px;
      line-height: 30px;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    .pause-close:hover {
      background: #ff4500;
      transform: scale(1.1);
    }

    /* === JOLLY SELECTOR === */
   #jollySelector {
   position: fixed;
   inset: 0; /* prende tutto lo schermo */
   display: flex;
   justify-content: center;
   align-items: center;
   background: rgba(5, 30, 10, 0.9);
   backdrop-filter: blur(10px);
   -webkit-backdrop-filter: blur(10px);
   z-index: 200; /* sopra HUD e canvas */
   }

    .selector-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      padding: 30px;
      border-radius: 20px;
      background: rgba(0, 0, 0, 0.7);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      max-width: 90%;
      width: 400px;
    }
    .selector-content h3 {
      font-size: 24px;
      color: #a8ff80;
      margin: 0;
    }
    .selector-controls {
      display: flex;
      align-items: center;
      gap: 20px;
    }
    .arrow-btn {
      width: 60px;
      height: 60px;
      display: grid;
      place-items: center;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }
    .arrow-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }
    .preview-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    .preview-name {
      font-size: 18px;
      color: #ffd700;
      font-weight: bold;
      text-align: center;
      min-height: 24px;
    }
    #previewCanvas {
      width: 80px;
      height: 80px;
      image-rendering: pixelated;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.2);
    }
    canvas { 
      image-rendering: -moz-crisp-edges; 
      image-rendering: pixelated; 
      image-rendering: crisp-edges;
    }
    body, canvas, * {
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <!-- MENU INIZIALE -->
  <div id="menu-overlay">
    <!-- SCHERMATA PRINCIPALE -->
    <div class="menu-screen active" id="screen-main">
      <div class="menu-title">BALL DROP</div>
      <button class="menu-btn" id="btnPlay">üéÆ GIOCA</button>
      <button class="menu-btn" id="btnOptions">‚öôÔ∏è OPZIONI</button>
      <button class="menu-btn" id="btnCredits">üìú CREDITI</button>
    </div>

    <!-- SCHERMATA MODALIT√Ä DI GIOCO -->
    <div class="menu-screen" id="screen-game-modes">
      <div class="menu-title">MODALIT√Ä</div>
      <button class="menu-btn" id="btnModeClassic">üéØ CLASSICA</button>
      <button class="menu-btn" id="btnModeMissions">üéØ MISSIONI</button>
      <button class="menu-btn" id="btnModeMultiplayer">üéØ MULTIPLAYER</button>
      <button class="menu-btn menu-back" id="btnBackModes">‚Üê INDIETRO</button>
    </div>

    <!-- SCHERMATA OPZIONI -->
    <div class="menu-screen" id="screen-options">
      <div class="menu-title">OPZIONI</div>
      <div class="settings-row">
        <span>Audio</span>
        <button class="toggle-btn" id="btnToggleAudio">üîä ON</button>
      </div>
<div class="settings-row">
  <span>Lingua</span>
  <select id="langSelect" class="toggle-btn" style="width: auto; padding: 6px 12px;">
    <option value="it">Italiano</option>
    <option value="sc">Sicilianu</option>
  </select>
</div>
<div class="settings-row">
  <span>Tema</span>
  <select id="themeSelect" class="toggle-btn" style="width: auto; padding: 6px 12px;">
    <option value="green">Verde</option>
    <option value="fire">Fuoco</option>
    <option value="night">Notte</option>
  </select>
</div>
<div class="settings-row">
  <span>Sfondo</span>
  <select id="bgSelect" class="toggle-btn" style="width: auto; padding: 6px 12px;">
    <option value="grass">Erba</option>
    <option value="concrete">Cemento</option>
    <option value="wood">Legno</option>
  </select>
</div>
      <div class="settings-row">
        <span>Trucchi</span>
        <button class="toggle-btn" id="btnEnableCheats">OFF</button>
      </div>
      <button class="menu-btn menu-back" id="btnBackOptions">‚Üê INDIETRO</button>
    </div>
    <!-- SCHERMATA CREDITI -->
    <div class="menu-screen" id="screen-credits">
      <div class="menu-title">CREDITI</div>
      <p class="credits-text">
        Realizzato con ‚ù§Ô∏è da <strong>Mirko Yuri Donato</strong><br>
        Il gioco presenta parti realizzati mediante l'uso del-<br>
        l'intelligenza artificiale, principalmente i Modelli GPT 5 <br>
        Qwen 3 di Alibaba Cloud, DeepSeek e Microsoft Copilot <br>
        Il codice sorgente √® rilasciato sotto la licenza MIT,<br>
        mentre gli assets sono sotto la<br>
        Creative Commons Attribution 4.0 International Public License.
      </p>
      <button class="menu-btn menu-back" id="btnBackCredits">‚Üê INDIETRO</button>
    </div>
  </div>

  <!-- MENU PAUSA -->
  <div id="pauseMenu" class="overlay hidden">
    <div class="pause-content">
      <div class="pause-title">PAUSA</div>
      <button class="pause-btn" id="btnResume">RIPRENDI</button>
      <button class="pause-btn" id="btnRestartPause">RIAVVIA</button>
      <button class="pause-btn" id="btnOptionsPause">OPZIONI</button>
      <button class="pause-btn" id="btnQuit">ESCI</button>
      <button class="pause-close" id="btnClosePause">√ó</button>
    </div>
  </div>

  <!-- SELEZIONE JOLLY -->
  <div id="jollySelector" class="overlay hidden">
    <div class="selector-content">
      <h3>SELEZIONA PALLA</h3>
      <div class="selector-controls">
        <button class="arrow-btn" id="btnPrev">‚Üê</button>
        <div class="preview-box">
          <div class="preview-name" id="previewName">Vortice</div>
          <canvas id="previewCanvas" width="80" height="80"></canvas>
        </div>
        <button class="arrow-btn" id="btnNext">‚Üí</button>
      </div>
      <button class="restart" id="btnSelectJolly">SELEZIONA</button>
    </div>
  </div>

  <!-- HUD (nascosto finch√© non si gioca) -->
  <div class="hud">
    <div class="score" id="score">PUNTEGGIO 000000</div>
    <div class="info">
      <div class="next">
        <span>Prossimo</span>
        <canvas id="nextIcon" width="48" height="48"></canvas>
      </div>
      <div class="level" id="level">LIVELLO 1</div>
      <div class="powerups" id="powerups">
        <div class="powerup" id="jolly" style="display: none;">
          <div class="powerup-icon jolly-icon"></div>
          <span>Jolly</span>
        </div>
        <div class="powerup" id="fuoco" style="display: none;">
          <div class="powerup-icon fuoco-icon"></div>
          <span>Fuoco</span>
        </div>
      </div>
    </div>
    <div>
      <button class="btn" id="pauseBtn" aria-label="Pausa">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5">
          <circle cx="12" cy="12" r="9" stroke-opacity="0.3"/>
          <path d="M10 8v8M14 8v8" stroke-linecap="round"/>
        </svg>
      </button>
      <button class="btn" id="inventoryBtn" aria-label="Inventario" style="display: none;">
        <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
          <path d="M4 7v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V7H4zm0-2h16v2H4V5zm4 4h8v2H8V9z"/>
        </svg>
      </button>
    </div>
  </div>

  <div id="wrap">
    <canvas id="game" width="480" height="720" aria-label="Campo di gioco"></canvas>
    <div class="center">
      <div id="gameOver" class="overlay hidden">
        <div class="title">GAME OVER</div>
        <div class="score-final" id="finalScore">PUNTEGGIO: 0</div>
        <div class="score-final" id="bestScore">RECORD: 0</div>
        <button class="restart" id="restartBtn">Rigioca</button>
      </div>
    </div>
  </div>

  <div class="hint" id="hint">Tieni premuto per "agganciare" la palla, trascina nella fascia alta e lascia per farla cadere!</div>
<script>
(() => {
  /* ==========================
     CONFIGURAZIONE
  ========================== */
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // Sfondo erboso
  const grass = document.createElement('canvas');
  grass.width = grass.height = 128;
  const gctx = grass.getContext('2d');
  gctx.fillStyle = '#1a4d2a';
  gctx.fillRect(0, 0, 128, 128);
  for (let i = 0; i < 200; i++) {
    gctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.06})`;
    gctx.fillRect(Math.random() * 128, Math.random() * 128, 1, 1);
  }
  for (let i = 0; i < 40; i++) {
    gctx.strokeStyle = `rgba(255,255,255,${Math.random() * 0.1})`;
    gctx.lineWidth = 0.5;
    gctx.beginPath();
    gctx.moveTo(0, i * 3 + Math.random() * 2);
    gctx.lineTo(128, i * 3 + Math.random() * 2);
    gctx.stroke();
  }
  const grassPat = ctx.createPattern(grass, 'repeat');

  // Tipi di palle
  const TYPES = [
    'golf','pingpong','squash','lacrosse','tennis','baseball','cricket','pallamano','pallavolo','basket','waterpolo','calcio','pallamedica',
    'bomba', 'vetro', 'vortice', 'detonatrice', 'metal', 'oro'
  ];
  const SCORE_STEP = [10,20,40,80,120,180,260,360,520,700,900,1000];
  const RADII = {
    golf:18, pingpong:20, squash:22, lacrosse:24, tennis:26, baseball:28, cricket:30, pallamano:32, pallavolo:36, basket:40, waterpolo:42, calcio:44, pallamedica:50,
    bomba: 30, vetro: 28, vortice: 32, detonatrice: 28, metal: 26, oro: 26
  };
  const MASSE = {
    golf:0.046, pingpong:0.0027, squash:0.024, lacrosse:0.145, tennis:0.058, baseball:0.145, cricket:0.163, pallamano:0.475, pallavolo:0.27, basket:0.62, waterpolo:0.45, calcio:0.43, pallamedica:3.0,
    bomba: 0.8, vetro: 0.1, vortice: 0.3, detonatrice: 0.2, metal: 0.6, oro: 0.5
  };
  const REST = {
    golf:.75, pingpong:.88, squash:.7, lacrosse:.65, tennis:.8, baseball:.55, cricket:.55, pallamano:.5, pallavolo:.65, basket:.75, waterpolo:.6, calcio:.72, pallamedica:.35,
    bomba: 0.4, vetro: 0.9, vortice: 0.6, detonatrice: 0.7, metal: 0.3, oro: 0.2
  };
  const FRICTION = 0.004;
  const MERGE_SPEED_THRESHOLD = 100;

class Ball {
  constructor(x, y, type, sprite) {
    this.id = Math.random().toString(36).slice(2);
    this.x = x;
    this.y = y;
    this.type = type;
    this.r = RADII[type];
    this.m = MASSE[type];
    this.rest = REST[type];
    this.sprite = sprite;
    this.vx = 0;
    this.vy = 0;
    this.ax = 0;
    this.ay = 0;
    this.held = false;
    this.asleep = false;
    this.squash = 0;
    this.merging = false;
  }
}

  // Meccaniche di livello
  let level = 1;
  const LEVEL_THRESHOLD = 500;
  const BASE_G = 1200;
  let G = BASE_G;
  const BASE_DANGER_HEIGHT = 120;
  let gameOverY = BASE_DANGER_HEIGHT;

  // Fascia alta per il posizionamento
  const TOP_BAND_HEIGHT = 120;
  let spawnY = Math.min(60, TOP_BAND_HEIGHT / 2);

  // Palle speciali
  const SPECIAL_TYPES = new Set(['bomba', 'vetro', 'vortice', 'detonatrice', 'metal', 'oro']);
  const SPECIAL_CHANCE = 0.1;

  // Limiti
  const MAX_BALLS = 30;
  const MAX_PARTICLES = 100;
  const DROP_COOLDOWN = 0.4;
  let lastDropTime = 0;

  // Stato globale
  let balls = [];
  let paused = false;
  let gameOver = false;
  let score = 0;
  let bestScore = parseInt(localStorage.getItem('ballDropBest') || '0');
  let highestTypeIndex = 0;
  let vortexEffect = null;

  // üíé Potenziamenti
  let hasJolly = false;
  let hasFuoco = false;
  let heldPowerup = null;

  const R = (a, b) => a + Math.random() * (b - a);

// üåç TRADUZIONI
const translations = {
  it: {
    play: "üéÆ GIOCA",
    options: "‚öôÔ∏è OPZIONI",
    credits: "üìú CREDITI",
    back: "‚Üê INDIETRO",
    audio: "Audio",
    cheats: "Trucchi",
    language: "Lingua",
    theme: "Tema",
    background: "Sfondo",
    resume: "RIPRENDI",
    restart: "RIAVVIA",
    quit: "ESCI",
    select: "SELEZIONA",
    paused: "PAUSED",
    next: "Prossimo",
    level: "LIVELLO",
    score: "PUNTEGGIO",
    gameOver: "GAME OVER",
    restartGame: "Rigioca",
    hint: "Tieni premuto per ‚Äúagganciare‚Äù la palla, trascina nella fascia alta e lascia per farla cadere!",
    creditsText: "Realizzato con ‚ù§Ô∏è da <strong>Mirko Yuri Donato</strong><br>Il gioco presenta parti realizzati mediante l'uso del-<br>l'intelligenza artificiale, principalmente i Modelli GPT 5<br>Qwen 3 di Alibaba Cloud, DeepSeek e Microsoft Copilot<br>Il codice sorgente √® rilasciato sotto la licenza MIT,<br>mentre gli assets sono sotto la<br>Creative Commons Attribution 4.0 International Public License."
  },
  sc: {
    play: "üéÆ GIOCA",
    options: "‚öôÔ∏è UZIONI",
    credits: "üìú CRIDITI",
    back: "‚Üê NDRU",
    audio: "Audio",
    cheats: "Trucchi",
    language: "Lingua",
    theme: "Tema",
    background: "Sfunnu",
    resume: "RIPRINNI",
    restart: "RIAVVIA",
    quit: "ESCI",
    select: "SCEGLI",
    paused: "PAUSATO",
    next: "Prossimu",
    level: "LIVELLU",
    score: "PUNTEGGIU",
    gameOver: "GAME OVER",
    restartGame: "Rigioca",
    hint: "Tieni primitu pi ‚Äúnciurrari‚Äù la palora, trascina nt√¢ fascia auta e lassa pi fari cadiri!",
    creditsText: "Fattu cu ‚ù§Ô∏è di <strong>Mirko Yuri Donato</strong><br>Lu jocu cci √† parti fattu cu l‚ÄôAI, principalmenti GPT 5,<br>Qwen 3 di Alibaba Cloud, DeepSeek e Microsoft Copilot<br>Lu codici √® sutta licenza MIT,<br>mmentri li assets sunnu sutta<br>Creative Commons Attribution 4.0 International."
  }
};

let currentLang = 'it';

function setLanguage(lang) {
  currentLang = lang;
  const t = translations[lang];
  
  // Menu principale
  document.getElementById('btnPlay').textContent = t.play;
  document.getElementById('btnOptions').textContent = t.options;
  document.getElementById('btnCredits').textContent = t.credits;
  document.getElementById('btnBackOptions').textContent = t.back;
  document.getElementById('btnBackCredits').textContent = t.back;
  
  // Opzioni
  document.querySelector('.settings-row:nth-child(2) span').textContent = t.audio;
  document.querySelector('.settings-row:nth-child(3) span').textContent = t.cheats;
  document.querySelector('.settings-row:nth-child(4) span').textContent = t.language;
  
  // Pausa
  document.getElementById('btnResume').textContent = t.resume;
  document.getElementById('btnRestartPause').textContent = t.restart;
  document.getElementById('btnOptionsPause').textContent = t.options;
  document.getElementById('btnQuit').textContent = t.quit;
  document.querySelector('.pause-title').textContent = t.paused;
  
  // HUD
  document.querySelector('.next span').textContent = t.next;
  levelEl.textContent = `${t.level} ${level}`;
  scoreEl.textContent = `${t.score} ${String(score).padStart(6, '0')}`;
  
  // Altri
  document.getElementById('btnSelectJolly').textContent = t.select;
  hintEl.textContent = t.hint;
  document.querySelector('.credits-text').innerHTML = t.creditsText;
  document.getElementById('restartBtn').textContent = t.restartGame;
  document.querySelector('.title').textContent = "GAME OVER"; // lasciamo in inglese per stile
  
  // Salva preferenza
  localStorage.setItem('ballDropLang', lang);
}

  // Funzione helper per esagono (calcio)
  function drawHex(cx, x, y, size) {
    cx.save();
    cx.translate(x, y);
    cx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = (i * Math.PI) / 3;
      const xx = Math.cos(angle) * size;
      const yy = Math.sin(angle) * size;
      if (i === 0) cx.moveTo(xx, yy);
      else cx.lineTo(xx, yy);
    }
    cx.closePath();
    cx.fill();
    cx.restore();
  }

  // Cache sprite
  const spriteCache = new Map();
  const imagePromises = [];

function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
    img.src = src;
  });
}

// UI ELEMENTS
const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');
const finalScoreEl = document.getElementById('finalScore');
const bestScoreEl = document.getElementById('bestScore');
const nextIcon = document.getElementById('nextIcon');
const nextCtx = nextIcon.getContext('2d');
const pauseBtn = document.getElementById('pauseBtn');
const inventoryBtn = document.getElementById('inventoryBtn');
const overEl = document.getElementById('gameOver');
const restartBtn = document.getElementById('restartBtn');
const hintEl = document.getElementById('hint');
const jollyEl = document.getElementById('jolly');
const fuocoEl = document.getElementById('fuoco');

// MENU ELEMENTS
const menuOverlay = document.getElementById('menu-overlay');
const screenMain = document.getElementById('screen-main');
const screenOptions = document.getElementById('screen-options');
const screenCredits = document.getElementById('screen-credits');
const btnPlay = document.getElementById('btnPlay');
const btnOptions = document.getElementById('btnOptions');
const btnCredits = document.getElementById('btnCredits');
const btnBackOptions = document.getElementById('btnBackOptions');
const btnBackCredits = document.getElementById('btnBackCredits');
const btnToggleAudio = document.getElementById('btnToggleAudio');
const btnEnableCheats = document.getElementById('btnEnableCheats');

// PAUSE MENU ELEMENTS
const pauseMenu = document.getElementById('pauseMenu');
const btnResume = document.getElementById('btnResume');
const btnRestartPause = document.getElementById('btnRestartPause');
const btnOptionsPause = document.getElementById('btnOptionsPause');
const btnQuit = document.getElementById('btnQuit');
const btnClosePause = document.getElementById('btnClosePause');

// JOLLY SELECTOR ELEMENTS
const jollySelector = document.getElementById('jollySelector');
const btnPrev = document.getElementById('btnPrev');
const btnNext = document.getElementById('btnNext');
const previewName = document.getElementById('previewName');
const previewCanvas = document.getElementById('previewCanvas');
const btnSelectJolly = document.getElementById('btnSelectJolly');
const previewCtx = previewCanvas.getContext('2d');
// === Parametri per la logica di game-over nella "linea rossa" ==========
const DANGER_STILL_SPEED = 20;    // px/s -> sotto questo valore la palla √® considerata "ferma"
const DANGER_TIME_LIMIT  = 5.0;   // secondi nella zona rossa prima del game over

// Funzione che attiva game over (personalizzala come vuoi)
function triggerGameOver(reasonBall) {
  gameOver = true;
  // feedback visivo / sonoro
  floatText('GAME OVER', W/2, H/2);
  sfx('gameover');
  // eventualmente evidenzia la palla che ha causato il game over
  if (reasonBall) {
    reasonBall.flash = 1.0; // se il renderer usa questo campo
  }
  // Eventuali ulteriori pulizie: stop suoni, salva score, ecc.
}


// margini interni del campo (coerenti con il bordo visivo del canvas)
const WALL = {
  left: 10,
  right: W - 10,
  bottom: H - 10
};

// Rimbalzo contro le pareti con correzione di penetrazione
function collideWithWalls(b) {
  const left   = WALL.left + b.r;
  const right  = WALL.right - b.r;
  const bottom = WALL.bottom - b.r;

  // Parete sinistra/destra (asse X)
  if (b.x < left) {
    b.x = left;
    if (b.vx < 0) b.vx = -b.vx * b.rest;
  } else if (b.x > right) {
    b.x = right;
    if (b.vx > 0) b.vx = -b.vx * b.rest;
  }

  // Pavimento (asse Y)
  if (b.y > bottom) {
    b.y = bottom;

    // gestione speciale per la palla "vetro": se non √® supportata, si rompe
    if (b.type === 'vetro') {
      let supported = false;
      for (const other of balls) {
        if (other === b || other.held) continue;
        if (other.y > b.y && Math.abs(b.x - other.x) < (b.r + other.r) * 0.8) {
          const gap = (b.y + b.r) - (other.y - other.r);
          if (gap < 5) { supported = true; break; }
        }
      }
      if (!supported) {
        floatText('SPLASH!', b.x, b.y);
        sfx('tink');
        // rimuovi la palla di vetro
        const i = balls.indexOf(b);
        if (i !== -1) balls.splice(i, 1);
        return;
      }
    }

    // rimbalzo con restituzione che scala col livello
    const effRest = Math.max(0.2, b.rest - (level - 1) * 0.04);
    b.vy = -Math.abs(b.vy) * effRest;
  }
}

// Clamp finale: impedisce in modo assoluto ogni uscita (anche se qualcosa sfugge)
function hardClamp(b) {
  b.x = Math.max(WALL.left + b.r, Math.min(WALL.right - b.r, b.x));
  b.y = Math.min(WALL.bottom - b.r, b.y);
}

// üé® TEMI
function applyTheme(theme) {
  const body = document.body;
  const hud = document.querySelector('.hud');
  const game = document.getElementById('game');
  
  // Rimuovi vecchi temi
  body.classList.remove('theme-green', 'theme-fire', 'theme-night');
  hud.classList.remove('theme-green', 'theme-fire', 'theme-night');
  game.classList.remove('theme-green', 'theme-fire', 'theme-night');
  
  // Applica nuovo tema
  body.classList.add(`theme-${theme}`);
  hud.classList.add(`theme-${theme}`);
  game.classList.add(`theme-${theme}`);
  
  localStorage.setItem('ballDropTheme', theme);
}

// üñºÔ∏è SFONDI
function applyBackground(bg) {
  // Puoi estendere `grassPat` con altri pattern in futuro
  // Per ora cambiamo solo il colore di sfondo del canvas
  localStorage.setItem('ballDropBg', bg);
}

// Inizializza temi
const savedTheme = localStorage.getItem('ballDropTheme') || 'green';
const savedBg = localStorage.getItem('ballDropBg') || 'grass';
document.getElementById('themeSelect').value = savedTheme;
document.getElementById('bgSelect').value = savedBg;
applyTheme(savedTheme);
applyBackground(savedBg);

// Eventi
document.getElementById('themeSelect').addEventListener('change', (e) => {
  applyTheme(e.target.value);
});
document.getElementById('bgSelect').addEventListener('change', (e) => {
  applyBackground(e.target.value);
});

// JOLLY SELECTABLE TYPES
const jollySelectableTypes = [
  'golf', 'pingpong', 'squash', 'tennis', 'basket', 'calcio', 'pallamedica',
  'bomba', 'vetro', 'vortice', 'detonatrice', 'metal', 'oro'
];
let jollySelectionIndex = 0;

function updateJollyPreview() {
  const type = jollySelectableTypes[jollySelectionIndex];
  previewName.textContent = type.charAt(0).toUpperCase() + type.slice(1);
  getSprite(type).then(sprite => {
    if (!sprite) return;
    previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
    const size = Math.min(previewCanvas.width, previewCanvas.height) * 0.8;
    const x = (previewCanvas.width - size) / 2;
    const y = (previewCanvas.height - size) / 2;
    previewCtx.imageSmoothingEnabled = false;
    previewCtx.drawImage(sprite, x, y, size, size);
  }).catch(()=>{});
}

btnPrev.addEventListener('click', () => {
  jollySelectionIndex = (jollySelectionIndex - 1 + jollySelectableTypes.length) % jollySelectableTypes.length;
  updateJollyPreview();
});

btnNext.addEventListener('click', () => {
  jollySelectionIndex = (jollySelectionIndex + 1) % jollySelectableTypes.length;
  updateJollyPreview();
});

btnSelectJolly.addEventListener('click', () => {
  const type = jollySelectableTypes[jollySelectionIndex];
  spawnBall(W/2, spawnY, type).then(ball => {
    if (!ball) return;
    ball.held = true;
    ball.asleep = false;
    heldBall = ball;
    setTimeout(() => {
      ball.held = false;
      heldBall = null;
      jollySelector.classList.remove('visible');
      jollySelector.classList.add('hidden');
      hasJolly = false;
      updatePowerupsUI();
    }, 50);
  }).catch(()=>{});
  jollySelectionIndex = 0;
});

// Funzione per mostrare le modalit√† di gioco
function showGameModes() {
  screenMain.classList.remove('active');
  screenGameModes.classList.add('active');
}

// Funzione per avviare il gioco
function startGame() {
  menuOverlay.style.display = 'none';
  document.querySelector('.hud').classList.add('visible');
  balls = [];
  score = 0;
  level = 1;
  highestTypeIndex = 0;
  paused = false;
  gameOver = false;
  vortexEffect = null;
  hasJolly = false;
  hasFuoco = false;
  heldPowerup = null;
  scoreEl.textContent = fmt(0);
  levelEl.textContent = `LIVELLO ${level}`;
  updatePowerupsUI();
  redrawNext();
  for (let i = 0; i < 4; i++) {
    spawnBall(R(80, W - 80), R(100, 200), 'golf');
  }
  setTimeout(() => {
    hintEl.classList.add('show');
    setTimeout(() => hintEl.classList.remove('show'), 3000);
  }, 500);
  loop();
}

// Sposta typeToImage GLOBALE, fuori da getSprite
const typeToImage = {
  'basket': 'palla_da_basket.png',
  'golf': 'palla_da_golf.png',
  'pallamano': 'palla_da_pallamano.png',
  'tennis': 'palla_da_tennis.png',
  'pingpong': 'palla_da_pingpong.png',
  'squash': 'palla_da_squash.png',
  'lacrosse': 'palla_da_lacrosse.png',
  'baseball': 'palla_da_baseball.png',
  'cricket': 'palla_da_cricket.png',
  'pallavolo': 'palla_da_pallavolo.png',
  'waterpolo': 'palla_da_waterpolo.png',
  'calcio': 'palla_da_calcio.png',
  'pallamedica': 'pallamedica.png',
  'bomba': 'bomba.png',
  'vetro': 'palla_di_vetro.png',
  'vortice': 'palla_vortice.png',
  'detonatrice': 'detonatrice.png',
  'metal': 'metal.png',
  'oro': 'oro.png',
  'jolly': 'jolly.png',
  'fuoco': 'fuoco.png'
};

/**
 * Carica o recupera dal cache lo sprite per un tipo di palla
 * @param {string} type - Tipo di palla (es. 'golf', 'bomba')
 * @returns {HTMLCanvasElement|null} Canvas con l'immagine ridimensionata
 */
async function getSprite(type) {
    if (spriteCache.has(type)) {
        return spriteCache.get(type);
    }
    let sprite = null;
    const imgPath = typeToImage[type];
    if (!imgPath) {
        console.warn(`[getSprite] Tipo sconosciuto: '${type}'`);
    } else {
        try {
            const fullPath = `assets/sprite/${imgPath}`;
            const img = await loadImage(fullPath);
            const r = RADII[type];
            const scale = 1.5;
            const sizePx = Math.ceil(r * 2 * DPR * scale);
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = sizePx;
            const ctx = canvas.getContext('2d');
            const drawSize = r * 2 * DPR * scale;
            const offset = (sizePx - drawSize) / 2;
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, offset, offset, drawSize, drawSize);
            sprite = canvas;
        } catch (err) {
            console.error(`Errore caricamento sprite per ${type}:`, err);
        }
    }
    if (!sprite) {
        console.error(`[Asset Mancante] '${type}' non caricato.`);
        const r = RADII[type] || 24;
        const scale = 1.5;
        const sizePx = Math.ceil(r * 2 * DPR * scale);
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = sizePx;
        const ctx = canvas.getContext('2d');
        const center = sizePx / 2;
        const radius = r * DPR * scale;
        ctx.translate(center, center);
        ctx.fillStyle = '#d32f2f';
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(-radius * 0.7, -radius * 0.7);
        ctx.lineTo(radius * 0.7, radius * 0.7);
        ctx.moveTo(-radius * 0.7, radius * 0.7);
        ctx.lineTo(radius * 0.7, -radius * 0.7);
        ctx.stroke();
        sprite = canvas;
    }
    spriteCache.set(type, sprite);
    return sprite;
}

// Pre-carica tutti gli sprite
let spritesLoaded = false;
(async () => {
  try {
    await Promise.all(TYPES.map(type => getSprite(type)));
    console.log('‚úÖ Tutti gli sprite sono stati caricati con successo.');
    spritesLoaded = true;
  } catch (err) {
    console.warn('‚ö†Ô∏è Alcuni sprite potrebbero non essere stati caricati:', err);
    spritesLoaded = true;
  }
})();

// Carica lingua salvata
const savedLang = localStorage.getItem('ballDropLang');
if (savedLang && translations[savedLang]) {
  currentLang = savedLang;
  document.getElementById('langSelect').value = savedLang;
}
setLanguage(currentLang);

// Cambia lingua al selezionare
document.getElementById('langSelect').addEventListener('change', (e) => {
  setLanguage(e.target.value);
});

btnPlay.addEventListener('click', () => {
  if (!spritesLoaded) {
    floatText('Caricamento...', W/2, H/2);
    return;
  }
  showGameModes();
});


btnOptions.addEventListener('click', () => {
  screenMain.classList.remove('active');
  screenOptions.classList.add('active');
});

btnCredits.addEventListener('click', () => {
  screenMain.classList.remove('active');
  screenCredits.classList.add('active');
});

// GAME MODES ELEMENTS
const screenGameModes = document.getElementById('screen-game-modes');
const btnModeClassic = document.getElementById('btnModeClassic');
const btnModeMissions = document.getElementById('btnModeMissions');
const btnModeMultiplayer = document.getElementById('btnModeMultiplayer');
const btnBackModes = document.getElementById('btnBackModes');

btnBackModes.addEventListener('click', () => {
  screenGameModes.classList.remove('active');
  screenMain.classList.add('active');
});

btnModeClassic.addEventListener('click', () => {
  screenGameModes.classList.remove('active');
  startGame();
});

btnModeMissions.addEventListener('click', () => {
  screenGameModes.classList.remove('active');
  showMissionsOverlay();
});

btnModeMultiplayer.addEventListener('click', () => {
  screenGameModes.classList.remove('active');
  showMultiplayerLobby();
});

btnBackOptions.addEventListener('click', () => {
  screenOptions.classList.remove('active');
  screenMain.classList.add('active');
});

btnBackCredits.addEventListener('click', () => {
  screenCredits.classList.remove('active');
  screenMain.classList.add('active');
});

// AUDIO TOGGLE
let audioEnabled = true;
btnToggleAudio.addEventListener('click', () => {
  audioEnabled = !audioEnabled;
  musicPlaying = audioEnabled;
  btnToggleAudio.textContent = audioEnabled ? 'üîä ON' : 'üîá OFF';
  btnToggleAudio.classList.toggle('off', !audioEnabled);
});

// CHEATS TOGGLE
let cheatsEnabled = false;
btnEnableCheats.addEventListener('click', () => {
  if (!cheatsEnabled) {
    enableCheats();
    btnEnableCheats.textContent = 'ON';
    btnEnableCheats.style.background = '#4caf50';
    cheatsEnabled = true;
    floatText('TRUCCHI ATTIVATI!', W/2, H/2);
    sfx('powerup');
  }
});

function fmt(n) { return 'PUNTEGGIO ' + String(n).padStart(6, '0'); }

function updatePowerupsUI() {
  jollyEl.style.display = hasJolly ? 'flex' : 'none';
  fuocoEl.style.display = hasFuoco ? 'flex' : 'none';
  inventoryBtn.style.display = (hasJolly || hasFuoco) ? 'grid' : 'none';
}

function addScore(n, x, y) {
  score += n;
  scoreEl.textContent = fmt(score);
  scoreEl.classList.add('highlight');
  setTimeout(() => scoreEl.classList.remove('highlight'), 300);
  floatText(`+${n}`, x, y);
  const newLevel = Math.floor(score / LEVEL_THRESHOLD) + 1;
  if (newLevel > level) {
    level = newLevel;
    onLevelUp();
  }
}

function onLevelUp() {
  for (const b of balls) {
    b.rest = Math.max(0.25, REST[b.type] - (level - 1) * 0.05);
  }
  floatText(`LIVELLO ${level}!`, W / 2, H / 2);
  levelEl.textContent = `LIVELLO ${level}`;
  sfx('boing');
  ctx.filter = 'blur(2px)';
  setTimeout(() => ctx.filter = 'none', 100);
}

// Particelle
let particles = [];
function spawnStars(x, y) {
  for (let i = 0; i < 12; i++) {
    const size = R(2, 5) * DPR;
    particles.push({
      x, y,
      vx: R(-120, 120),
      vy: R(-180, -60),
      life: R(0.6, 1.0),
      t: 0,
      color: ['#ffd700', '#ffaa00', '#ffffff'][Math.floor(R(0, 3))],
      size,
      rotation: R(0, Math.PI * 2),
      type: 'star'
    });
  }
}

function floatText(t, x, y) {
  particles.push({
    text: t,
    x, y,
    vx: R(-20, 20),
    vy: -60,
    life: 1.0,
    t: 0,
    color: '#ffdd00',
    size: 20
  });
}

// Audio
let AudioContext = window.AudioContext || window.webkitAudioContext;
let Audio = null;
let musicPlaying = true;

function initAudio() {
  if (!Audio) {
    Audio = new AudioContext();
  }
}

function sfx(kind) {
  if (!musicPlaying || !Audio) return;
  try {
    const g = Audio.createGain();
    g.connect(Audio.destination);
    g.gain.value = 0.15;
    const o = Audio.createOscillator();
    o.connect(g);
    const now = Audio.currentTime;
    switch (kind) {
      case 'tink': o.type = 'sine'; o.frequency.setValueAtTime(700, now); o.frequency.exponentialRampToValueAtTime(500, now + 0.1); break;
      case 'boing': o.type = 'triangle'; o.frequency.setValueAtTime(200, now); o.frequency.exponentialRampToValueAtTime(150, now + 0.15); break;
      case 'merge': o.type = 'sawtooth'; o.frequency.setValueAtTime(400, now); o.frequency.exponentialRampToValueAtTime(250, now + 0.2); break;
      case 'powerup': o.type = 'square'; o.frequency.setValueAtTime(800, now); o.frequency.exponentialRampToValueAtTime(600, now + 0.15); break;
    }
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.3, now + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
    o.start(now);
    o.stop(now + 0.26);
  } catch (e) {}
}

// Attiva audio al primo tocco
document.addEventListener('touchstart', initAudio, { once: true });
document.addEventListener('click', initAudio, { once: true });

// üîÅ SISTEMA DI DROP CON ANTI-SPAM
let heldBall = null;
let isDragging = false;
let currentPointerId = null;

canvas.addEventListener('pointerdown', (e) => {
    if (gameOver || paused || isDragging) return;
    const now = performance.now() / 1000;
    if (now - lastDropTime < DROP_COOLDOWN) {
        floatText('Aspetta!', W / 2, H / 2);
        sfx('tink');
        return;
    }
    const rect = canvas.getBoundingClientRect();
    let x = (e.clientX - rect.left) / rect.width * W;
    if (x < 10 || x > W - 10) return;
    let type;
    if (level >= 5 && Math.random() < SPECIAL_CHANCE) {
        const choices = ['bomba', 'vetro', 'vortice', 'detonatrice'];
        if (level >= 7 && Math.random() < 0.3) choices.push('metal');
        if (level >= 10 && Math.random() < 0.1) choices.push('oro');
        type = choices[Math.floor(Math.random() * choices.length)];
    } else {
        type = TYPES[Math.floor(R(0, Math.min(highestTypeIndex + 1, 5)))];
    }
    if (balls.length >= MAX_BALLS) return;
    spawnBall(x, spawnY, type).then(ball => {
        if (!ball) return;
        heldBall = ball;
        heldBall.vx = 0;
        heldBall.vy = 0;
        heldBall.held = true;
        heldBall.asleep = false;
        isDragging = true;
        currentPointerId = e.pointerId;
        e.preventDefault();
        canvas.setPointerCapture(e.pointerId);
        floatText('PRONTO', x, spawnY - 20);
        sfx('tink');
        lastDropTime = now;
    }).catch(()=>{});
});

canvas.addEventListener('pointermove', (e) => {
    if (!isDragging || !heldBall || e.pointerId !== currentPointerId) return;
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const newX = (e.clientX - rect.left) / rect.width * W;
    const minX = 10 + heldBall.r;
    const maxX = W - 10 - heldBall.r;
    heldBall.x = Math.max(minX, Math.min(maxX, newX));
    heldBall.y = spawnY;
});

canvas.addEventListener('pointerup', (e) => {
    if (!isDragging || !heldBall || e.pointerId !== currentPointerId) return;
    heldBall.held = false;
    heldBall.asleep = false;
    isDragging = false;
    heldBall = null;
    try {
        canvas.releasePointerCapture(currentPointerId);
    } catch (e) {}
    currentPointerId = null;
});

canvas.addEventListener('pointercancel', (e) => {
    if (!isDragging || !heldBall || e.pointerId !== currentPointerId) return;
    heldBall.held = false;
    heldBall.asleep = false;
    isDragging = false;
    heldBall = null;
    try {
        canvas.releasePointerCapture(currentPointerId);
    } catch (e) {}
    currentPointerId = null;
});

// === NUOVO: GESTIONE MENU PAUSA ===
pauseBtn.addEventListener('click', () => {
  if (gameOver) return;
  paused = !paused;
  pauseBtn.style.opacity = paused ? 0.6 : 1;
  if (paused) {
    sfx('boing');
    pauseMenu.classList.remove('hidden');
    pauseMenu.classList.add('visible');
  } else {
    pauseMenu.classList.remove('visible');
    pauseMenu.classList.add('hidden');
  }
});

// PULSANTI MENU PAUSA
btnResume.addEventListener('click', () => {
  paused = false;
  pauseBtn.style.opacity = 1;
  pauseMenu.classList.remove('visible');
  pauseMenu.classList.add('hidden');
});

btnRestartPause.addEventListener('click', () => {
  pauseMenu.classList.remove('visible');
  pauseMenu.classList.add('hidden');
  resetGame();
});

btnOptionsPause.addEventListener('click', () => {
  pauseMenu.classList.remove('visible');
  pauseMenu.classList.add('hidden');
  screenMain.classList.remove('active');
  screenOptions.classList.add('active');
});

btnQuit.addEventListener('click', () => {
  pauseMenu.classList.remove('visible');
  pauseMenu.classList.add('hidden');
  // ‚úÖ Mostra il menu principale e nascondi tutte le sottoschermate
  screenOptions.classList.remove('active');
  screenCredits.classList.remove('active');
  screenMain.classList.add('active');
  menuOverlay.style.display = 'flex';
  document.querySelector('.hud').classList.remove('visible');
  resetGame();
});

btnOptionsPause.addEventListener('click', () => {
  pauseMenu.classList.remove('visible');
  pauseMenu.classList.add('hidden');
  // ‚úÖ Mostra SOLO la schermata opzioni
  screenMain.classList.remove('active');
  screenCredits.classList.remove('active');
  screenOptions.classList.add('active');
  menuOverlay.style.display = 'flex';
});

inventoryBtn.addEventListener('click', () => {
  if (hasFuoco) {
    floatText('FUOCO!', W / 2, H / 2);
    sfx('powerup');
    for (const b of balls) {
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: b.x, y: b.y,
          vx: R(-100, 100), vy: R(-150, 150),
          life: R(0.3, 0.7), t: 0,
          color: '#ff4500', size: R(2, 4)
        });
      }
    }
    balls = [];
    hasFuoco = false;
  } else if (hasJolly) {
    jollySelector.classList.remove('hidden');
    jollySelector.classList.add('visible');
    updateJollyPreview();
    floatText('JOLLY: Seleziona una palla', W / 2, H / 2);
    sfx('powerup');
  }
  updatePowerupsUI();
});

restartBtn.addEventListener('click', resetGame);

// Reset pulito
function resetGame() {
  balls = [];
  particles = [];
  score = 0;
  level = 1;
  highestTypeIndex = 0;
  paused = false;
  gameOver = false;
  vortexEffect = null;
  hasJolly = false;
  hasFuoco = false;
  heldPowerup = null;
  jollySelector.classList.remove('visible');
  jollySelector.classList.add('hidden');
  scoreEl.textContent = fmt(0);
  levelEl.textContent = `LIVELLO ${level}`;
  updatePowerupsUI();
  redrawNext();
  for (let i = 0; i < 4; i++) {
    spawnBall(R(80, W - 80), R(100, 200), 'golf');
  }
  overEl.classList.remove('visible');
  setTimeout(() => overEl.classList.add('hidden'), 300);
}

async function spawnBall(x, y, type) {
  if (!type) return null;
  const r = RADII[type];
  let sprite = null;
  if (spriteCache.has(type)) {
    sprite = spriteCache.get(type);
  } else {
    const imgPath = `assets/sprite/${typeToImage[type]}`;
    try {
      const img = await loadImage(imgPath);
      const s = Math.ceil(r * 2 * DPR + 10);
      const c = document.createElement('canvas');
      c.width = c.height = s;
      const cx = c.getContext('2d');
      const size = r * 2 * DPR;
      cx.drawImage(img, (s - size) / 2, (s - size) / 2, size, size);
      sprite = c;
      spriteCache.set(type, sprite);
    } catch (err) {
      console.warn('Impossibile caricare immagine:', imgPath, err);
      sprite = await getSprite(type);
    }
  }
  const ball = new Ball(x, y, type, sprite);
  balls.push(ball);
  return ball;
}

async function redrawNext() {
    nextCtx.clearRect(0, 0, nextIcon.width, nextIcon.height);
    const idx = Math.min(highestTypeIndex + 1, TYPES.length - 1);
    const type = TYPES[idx];
    const s = await getSprite(type);
    if (!s) {
        console.error(`Sprite non trovato per il tipo: ${type}`);
        return;
    }
    const sz = 48 * DPR;
    const x = (nextIcon.width - sz) / 2;
    const y = (nextIcon.height - sz) / 2;
    nextCtx.imageSmoothingEnabled = false;
    nextCtx.drawImage(s, x, y, sz, sz);
}

// üî• Bomba
function explode(x, y) {
  sfx('boing');
  floatText('BOOM!', x, y);
  for (let i = 0; i < 20; i++) {
      particles.push({
          x, y,
          vx: R(-200, 200),
          vy: R(-250, -60),
          life: R(0.5, 0.9),
          t: 0,
          color: ['#ff4500', '#ff8c00', '#ffd700'][Math.floor(R(0, 3))],
          size: R(3, 6) * DPR
      });
  }
  const survivors = [];
  for (const b of balls) {
      const dist = Math.hypot(b.x - x, b.y - y);
      if (dist < 80) {
          if (b.type === 'metal') {
              hasJolly = true;
              floatText('JOLLY!', b.x, b.y);
              sfx('powerup');
          } else if (b.type === 'oro') {
              addScore(500, b.x, b.y);
              if (Math.random() < 0.7) {
                  hasJolly = true;
                  floatText('JOLLY!', b.x, b.y);
              } else {
                  hasFuoco = true;
                  floatText('FUOCO!', b.x, b.y);
              }
              sfx('powerup');
          }
      } else {
          survivors.push(b);
      }
  }
  balls = survivors;
  updatePowerupsUI();
}

function checkCrush() {
  for (const top of balls) {
    if (top.asleep && !top.held) {
      for (const bottom of balls) {
        if (bottom.asleep || bottom.type === 'vetro' || bottom.held) continue;
        if (top === bottom) continue;
        const dy = bottom.y - top.y;
        const dx = Math.abs(bottom.x - top.x);
        if (dy > 0 && dy < 30 && dx < (top.r + bottom.r) * 0.6 && top.r > bottom.r + 8) {
          floatText('CRUSH!', bottom.x, bottom.y);
          balls = balls.filter(b => b !== bottom);
          sfx('boing');
          return;
        }
      }
    }
  }
}
function detonateAllBombs() {
  balls = balls.filter(ball => ball.type !== 'bomba');
}

// === UPDATE con timer per zona rossa ===================================
function update(dt) {
  if (paused || gameOver) return;

  // aggiorna gravit√† / linea pericolo come prima
  G = BASE_G + (level - 1) * 100;
  gameOverY = Math.min(300, BASE_DANGER_HEIGHT + (level - 1) * 10);

  // üî• CORREZIONE: RIMUOVI IL "continue" PER LE PALLE ASLEEP
  for (const b of balls) {
    // Inizializza timer se mancante
    if (typeof b.dangerTimer !== 'number') b.dangerTimer = 0;

    // üî• APPLICA FISICA SOLO SE NON √à TENUTA E NON √à TROPPO FERMA
    if (!b.held && !b.asleep) {
      // integrazione fisica (sub-stepping per evitare tunneling)
      b.vy += G * dt;
      b.vx *= (1 - FRICTION);

      const maxDist = Math.max(Math.abs(b.vx * dt), Math.abs(b.vy * dt));
      const stepSize = Math.max(1, b.r * 0.4);
      const steps = Math.min(8, Math.max(1, Math.ceil(maxDist / stepSize)));
      const hdt = dt / steps;

      for (let s = 0; s < steps; s++) {
        b.x += b.vx * hdt;
        b.y += b.vy * hdt;
        collideWithWalls(b);
      }

      hardClamp(b);

      // üî• CORREZIONE: LOGICA SLEEP MIGLIORATA
      const speed = Math.hypot(b.vx, b.vy);
      if (speed < 5 && b.y >= H - 20 - b.r) {
        // Solo se √® quasi ferma E vicino al fondo
        b.asleep = true;
        b.vx = 0;
        b.vy = 0;
      }
    }

    // ----- LOGICA: timer per la zona rossa -----
    const topOfBall = b.y - b.r;
    const inDangerZone = topOfBall <= gameOverY;

    // velocit√† reale (modulo)
    const speed = Math.hypot(b.vx, b.vy);

    if (inDangerZone && !b.held) {
      if (speed <= DANGER_STILL_SPEED) {
        b.dangerTimer += dt;
        if (b.dangerTimer > 0.2) {
          floatText((DANGER_TIME_LIMIT - b.dangerTimer).toFixed(1) + 's', b.x, b.y - b.r - 12);
        }

        if (b.dangerTimer >= DANGER_TIME_LIMIT) {
          triggerGameOver(b);
          return;
        }
      } else {
        b.dangerTimer = 0;
      }
    } else {
      b.dangerTimer = 0;
    }
  }

  // Vortex effect - üî• CORREZIONE: RISVEGLIA LE PALLE
  if (vortexEffect) {
    vortexEffect.duration -= dt;
    if (vortexEffect.duration <= 0) {
      vortexEffect = null;
    } else {
      for (const b of balls) {
        if (b.type === 'vortice' || b.held) continue;
        const dx = vortexEffect.x - b.x;
        const dy = vortexEffect.y - b.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 120) {
          const force = (120 - dist) / 120 * 400 * dt;
          b.vx += (dx / dist) * force;
          b.vy += (dy / dist) * force;
          // üî• RISVEGLIA LA PALLA SE √à IN VORTICE
          b.asleep = false;
        }
      }
    }
  }

  // Collisioni tra palle - üî• CORREZIONE: RISVEGLIA LE PALLE IN COLLISIONE
  const cell = 64;
  const grid = new Map();
  function key(i, j) { return `${i},${j}`; }
  
  for (const b of balls) {
    if (b.held) continue;
    const i = Math.floor(b.x / cell), j = Math.floor(b.y / cell);
    for (let ii = i - 1; ii <= i + 1; ii++) {
      for (let jj = j - 1; jj <= j + 1; jj++) {
        const k = key(ii, jj);
        if (!grid.has(k)) grid.set(k, []);
        grid.get(k).push(b);
      }
    }
  }

  const pairs = new Set();
  for (const arr of grid.values()) {
    for (let a = 0; a < arr.length; a++) {
      for (let d = a + 1; d < arr.length; d++) {
        const A = arr[a], B = arr[d];
        const id = A.id < B.id ? A.id + '|' + B.id : B.id + '|' + A.id;
        if (pairs.has(id)) continue;
        pairs.add(id);
        
        const dx = B.x - A.x, dy = B.y - A.y;
        const dist2 = dx * dx + dy * dy;
        const rr = A.r + B.r;
        if (dist2 > rr * rr) continue;
        
        const dist = Math.sqrt(dist2) || 1;
        const nx = dx / dist, ny = dy / dist;
        const overlap = rr - dist;
        const totalMass = A.m + B.m;
        const aShare = B.m / totalMass, bShare = A.m / totalMass;
        
        A.x -= nx * overlap * aShare;
        A.y -= ny * overlap * aShare;
        B.x += nx * overlap * bShare;
        B.y += ny * overlap * bShare;
        
        const rvx = B.vx - A.vx, rvy = B.vy - A.vy;
        const velAlongNormal = rvx * nx + rvy * ny;
        
        if (velAlongNormal < 0) {
          const e = Math.min(A.rest, B.rest) * 1.1;
          const j = -(1 + e) * velAlongNormal / (1 / A.m + 1 / B.m);
          const impX = j * nx, impY = j * ny;
          
          A.vx -= impX / A.m;
          A.vy -= impY / A.m;
          B.vx += impX / B.m;
          B.vy += impY / B.m;
          
          A.squash = B.squash = Math.min(1.5, Math.abs(velAlongNormal) / 400);
          
          // üî• IMPORTANTE: RISVEGLIA LE PALLE IN COLLISIONE
          A.asleep = false;
          B.asleep = false;
        }
        
        if (A.type === B.type && !A.merging && !B.merging && Math.hypot(rvx, rvy) < MERGE_SPEED_THRESHOLD && A.held === B.held) {
          if (A.type === 'bomba') {
            explode((A.x + B.x) / 2, (A.y + B.y) / 2);
            balls = balls.filter(b => b !== A && b !== B);
          } else if (A.type === 'detonatrice') {
            detonateAllBombs();
            balls = balls.filter(b => b !== A && b !== B);
          } else if (A.type === 'metal' || A.type === 'oro') {
            // Non fare nulla per metal e oro
          } else {
            mergeBalls(A, B);
          }
        }
      }
    }
  }
  
  // Check game over
  for (const b of balls) {
    if (b.dangerTimer >= DANGER_TIME_LIMIT) {
      triggerGameOver(b);
      return;
    }
  }
  
  // Check crush
  checkCrush();

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.t += dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 600 * dt;
    if (p.type === 'star') p.rotation += 0.2;
    if (p.t > p.life) particles.splice(i, 1);
    if (particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);
  }
}

function mergeBalls(A, B) {
  sfx('merge');
  spawnStars((A.x + B.x) / 2, (A.y + B.y) / 2);
  const baseType = A.type;
  const idx = TYPES.indexOf(baseType);
  const scoreBonus = (A.type === 'vetro' || B.type === 'vetro') ? 3 : 1;
  if (idx < SCORE_STEP.length) {
    addScore(SCORE_STEP[idx] * scoreBonus, (A.x + B.x) / 2, (A.y + B.y) / 2);
  }
  A.merging = B.merging = true;
  const totalMass = A.m + B.m;
  const x = (A.x * A.m + B.x * B.m) / totalMass;
  const y = (A.y * A.m + B.y * B.m) / totalMass;
  const vx = (A.vx * A.m + B.vx * B.m) / totalMass;
  const vy = (A.vy * A.m + B.vy * B.m) / totalMass;
  balls = balls.filter(b => b !== A && b !== B);
  const nextIdx = Math.min(idx + 1, TYPES.length - 1);
  const newType = TYPES[nextIdx];
  const C = {
    id: Math.random().toString(36).slice(2),
    type: newType,
    x, y, vx, vy,
    r: RADII[newType],
    m: MASSE[newType],
    rest: REST[newType],
    squash: 0,
    merging: false,
    asleep: false,
    held: false
  };
  balls.push(C);
  if (!SPECIAL_TYPES.has(newType)) {
    highestTypeIndex = Math.max(highestTypeIndex, nextIdx);
  }
  redrawNext();
  if (newType === 'vortice') {
    vortexEffect = { x: C.x, y: C.y, duration: 2.0 };
    floatText('VORTICE!', C.x, C.y - 40);
    sfx('tink');
  }
}

const CHEAT_CODES = {
  "BALLDROP": () => { enableCheats(); },
  "GODMODE": () => {
    score = 999999;
    level = 99;
    hasJolly = true;
    hasFuoco = true;
    updatePowerupsUI();
    levelEl.textContent = `LIVELLO ${level}`;
    scoreEl.textContent = fmt(score);
    floatText('GOD MODE!', W/2, H/2);
    sfx('powerup');
  },
  "SPAWNGOLF": () => spawnBall(W/2, spawnY, 'golf'),
  "SPAWNBASKET": () => spawnBall(W/2, spawnY, 'basket'),
  "SPAWNORO": () => spawnBall(W/2, spawnY, 'oro'),
  "ADD10K": () => addScore(10000, W/2, 50),
  "CLEAR": () => { balls = []; floatText('CAMPO LIBERO!', W/2, H/2); },
  "VORTEX": () => {
    vortexEffect = { x: W/2, y: H/2, duration: 5.0 };
    floatText('VORTICE MANUALE!', W/2, H/2 - 40);
  }
};

let cheatBuffer = "";
function enableCheats() {
  window.cheats = {
    addScore: (n) => addScore(n, W/2, 50),
    setLevel: (l) => {
      level = l;
      levelEl.textContent = `LIVELLO ${level}`;
      onLevelUp();
    },
    spawn: (type) => spawnBall(W/2, spawnY, type),
    giveJolly: () => { hasJolly = true; updatePowerupsUI(); floatText('JOLLY!', W/2, 50); },
    giveFuoco: () => { hasFuoco = true; updatePowerupsUI(); floatText('FUOCO!', W/2, 50); },
    godMode: () => CHEAT_CODES["GODMODE"](),
    clear: () => CHEAT_CODES["CLEAR"]()
  };
  console.log("%cüéÆ TRUCCHI ATTIVATI! Comandi disponibili:", "color: #ffdd00; font-weight: bold");
  console.log(`- cheats.addScore(1000)`);
  console.log(`- cheats.setLevel(10)`);
  console.log(`- cheats.spawn('oro')`);
  console.log(`- cheats.giveJolly()`);
  console.log(`- cheats.godMode()`);
  console.log(`- cheats.clear()`);
}

document.addEventListener('keydown', (e) => {
  if (gameOver) return;
  cheatBuffer += e.key.toUpperCase();
  if (cheatBuffer.length > 10) {
    cheatBuffer = cheatBuffer.slice(-10);
  }
  for (const [code, action] of Object.entries(CHEAT_CODES)) {
    if (cheatBuffer.endsWith(code)) {
      cheatBuffer = "";
      action();
      break;
    }
  }
});

function draw() {
  ctx.save();
  ctx.fillStyle = grassPat;
  ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
  ctx.fillRect(0, 0, W, gameOverY);
  ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, gameOverY);
  ctx.lineTo(W, gameOverY);
  ctx.stroke();
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 2;
  ctx.strokeRect(8, 8, W - 16, H - 16);
  ctx.restore();
  const sortedBalls = [...balls].sort((a, b) => a.y - b.y);
  for (const b of sortedBalls) {
    const sprite = spriteCache.get(b.type);
    if (!sprite) {
      console.warn(`[draw] Sprite non trovato per '${b.type}', saltato`);
      continue;
    }
    const sx = sprite.width / 2;
    const sy = sprite.height / 2;
    const squish = 1 - Math.min(0.3, b.squash * 0.3);
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.scale(1 / squish, squish);
    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetY = 4;
    ctx.drawImage(sprite, -sx, -sy, sprite.width, sprite.height);
    ctx.restore();
    b.squash *= 0.7;
  }
  if (vortexEffect) {
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.strokeStyle = '#7b68ee';
    ctx.lineWidth = 3;
    for (let i = 0; i < 3; i++) {
      const radius = 40 + i * 20;
      ctx.beginPath();
      ctx.arc(vortexEffect.x, vortexEffect.y, radius, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.restore();
  }
  ctx.save();
  for (const p of particles) {
    const alpha = 1 - p.t / p.life;
    if (alpha <= 0) continue;
    ctx.globalAlpha = alpha;
    if (p.text) {
      ctx.font = `bold ${p.size}px sans-serif`;
      ctx.fillStyle = p.color;
      ctx.textAlign = 'center';
      ctx.fillText(p.text, p.x, p.y);
    } else {
      ctx.save();
      ctx.translate(p.x, p.y);
      if (p.rotation !== undefined) ctx.rotate(p.rotation);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
      ctx.restore();
    }
  }
  ctx.restore();
  ctx.globalAlpha = 1;
}

let acc = 0;
let last = performance.now();
const dtFixed = 1 / 120;

function loop() {
  const now = performance.now();
  let dt = (now - last) / 1000;
  last = now;
  if (dt > 0.2) dt = 0.1;
  acc += dt;
  while (acc >= dtFixed && !paused && !gameOver) {
    update(dtFixed);
    acc -= dtFixed;
  }
  draw();
  requestAnimationFrame(loop);
}
// MULTIPLAYER
function showMultiplayerLobby() {
  let html = `
    <div class="multiplayer-overlay">
      <div class="lobby">
        <h2>Multiplayer</h2>
        <div class="lobby-buttons">
          <button onclick="multiplayer.createRoom()">Crea Stanza</button>
          <button onclick="showJoinRoomInput()">Unisciti a Stanza</button>
          <button onclick="startHotSeatGame()">Hot Seat</button>
          <button onclick="document.getElementById('multiplayerOverlay').remove(); showGameModes();">Indietro</button>
        </div>
      </div>
    </div>
  `;

  const overlay = document.createElement('div');
  overlay.id = 'multiplayerOverlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  `;
  overlay.innerHTML = html;
  document.body.appendChild(overlay);
}

function showJoinRoomInput() {
  const roomId = prompt("Inserisci il codice stanza:");
  if (roomId) {
    multiplayer.joinRoom(roomId);
  }
}

function startHotSeatGame() {
  const hotSeat = new HotSeatMultiplayer({
    resetGame,
    score: 0,
    level: 1,
    balls: [],
    update: () => {},
    spawnBall: (x, y, type) => {
      const ball = spawnBall(x, y, type);
      balls.push(ball);
      return ball;
    }
  });
  hotSeat.startGame();
}

// Classe HotSeatMultiplayer (come da codice precedente)
class HotSeatMultiplayer {
  constructor(gameInstance) {
    this.game = gameInstance;
    this.players = [];
    this.currentPlayerIndex = 0;
    this.scores = new Map();
  }
  
  addPlayer(name) {
    const player = {
      id: this.generateId(),
      name: name,
      color: this.getRandomColor()
    };
    
    this.players.push(player);
    this.scores.set(player.id, 0);
    
    return player;
  }
  
  generateId() {
    return Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
  }
  
  getRandomColor() {
    const colors = ['#FF5733', '#33FF57', '#3357FF', '#F333FF'];
    return colors[Math.floor(Math.random() * colors.length)];
  }
  
  startGame() {
    if (this.players.length < 2) {
      this.addPlayer('Giocatore 1');
      this.addPlayer('Giocatore 2');
    }
    
    this.currentPlayerIndex = 0;
    this.showTurnIndicator();
    this.game.resetGame();
  }
  
  nextTurn() {
    const currentPlayer = this.players[this.currentPlayerIndex];
    this.scores.set(currentPlayer.id, this.game.score);
    
    this.currentPlayerIndex = (this.currentPlayerIndex + 1) % this.players.length;
    
    this.game.resetGame();
    this.showTurnIndicator();
  }
  
  showTurnIndicator() {
    const player = this.players[this.currentPlayerIndex];
    floatText(`Tocca a ${player.name}`, W/2, H/2);
    this.showHotSeatHUD();
  }
  
  showHotSeatHUD() {
    const hudHTML = this.players.map((player, index) => `
      <div class="player-score ${index === this.currentPlayerIndex ? 'active' : ''}">
        ${player.name}: ${this.scores.get(player.id) || 0}
      </div>
    `).join('');
    
    let hud = document.getElementById('hotSeatHUD');
    if (!hud) {
      hud = document.createElement('div');
      hud.id = 'hotSeatHUD';
      hud.style.cssText = `
        position: fixed;
        top: 100px;
        right: 20px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 10px;
        color: white;
        z-index: 100;
      `;
      document.body.appendChild(hud);
    }
    
    hud.innerHTML = hudHTML;
  }
  
  endGame() {
    const winner = this.players.reduce((prev, current) => 
      (this.scores.get(current.id) > this.scores.get(prev.id)) ? current : prev
    );
    
    floatText(`Vince ${winner.name}!`, W/2, H/2);
  }
}

// MISSIONI
let missions = [
  { id: 'fuse_3_golf', text: 'Fai fondere 3 palle da golf', completed: false, target: 3, current: 0 },
  { id: 'fuse_2_vetro', text: 'Fai fondere 2 palle di vetro', completed: false, target: 2, current: 0 },
  { id: 'drop_10_bombs', text: 'Lascia cadere 10 bombe', completed: false, target: 10, current: 0 },
  { id: 'score_5000', text: 'Raggiungi 5000 punti', completed: false, target: 5000, current: 0 }
];

function showMissionsOverlay() {
  let html = `
    <div class="missions-content">
      <h3>MISSIONI</h3>
  `;
  for (const m of missions) {
    html += `
      <div class="mission-item ${m.completed ? 'completed' : m.current >= m.target ? 'completed' : ''}">
        ${m.text} (${m.current}/${m.target})
      </div>
    `;
  }
  html += `<button class="restart" onclick="startGame(); document.getElementById('missionsOverlay').remove();">INIZIA</button>`;
  html += `<button class="menu-btn menu-back" onclick="document.getElementById('missionsOverlay').remove(); showGameModes();">INDIETRO</button>`;
  html += `</div>`;

  const overlay = document.createElement('div');
  overlay.id = 'missionsOverlay';
  overlay.className = 'overlay visible';
  overlay.innerHTML = html;
  document.body.appendChild(overlay);
}

function showGameModes() {
  screenMain.classList.remove('active');
  screenGameModes.classList.add('active');
}

function updateMissions(action, data) {
  for (const m of missions) {
    if (m.completed) continue;

    if (m.id === 'fuse_3_golf' && action === 'merge' && data.type === 'golf') {
      m.current++;
      if (m.current >= m.target) m.completed = true;
    }
    if (m.id === 'fuse_2_vetro' && action === 'merge' && data.type === 'vetro') {
      m.current++;
      if (m.current >= m.target) m.completed = true;
    }
    if (m.id === 'drop_10_bombs' && action === 'spawn' && data.type === 'bomba') {
      m.current++;
      if (m.current >= m.target) m.completed = true;
    }
    if (m.id === 'score_5000' && action === 'score' && score >= m.target) {
      m.current = score;
      m.completed = true;
    }
  }
}

// Classe BallDropMultiplayer (come da codice precedente)
class BallDropMultiplayer {
    constructor(gameInstance) {
        this.game = gameInstance;
        this.connections = new Map();
        this.players = new Map();
        this.localPlayer = {
            id: this.generateId(),
            name: 'Player_' + Math.floor(Math.random() * 1000),
            score: 0,
            ready: false
        };
        
        this.roomId = null;
        this.isHost = false;
        this.dataChannel = null;
        this.peer = null;
        
        this.setupEventListeners();
    }

    generateId() {
        return Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
    }

    setupEventListeners() {
        window.addEventListener('storage', this.handleStorageEvent.bind(this));
        window.addEventListener('hashchange', this.handleHashChange.bind(this));
    }

    handleHashChange() {
        const hash = window.location.hash.substring(1);
        if (hash && !this.roomId) {
            this.joinRoom(hash);
        }
    }

    createRoom(roomName = 'BallDrop Room') {
        this.roomId = Math.random().toString(36).substr(2, 8);
        this.isHost = true;
        
        window.location.hash = this.roomId;
        
        this.broadcastSignal({
            type: 'room_created',
            roomId: this.roomId,
            roomName: roomName,
            host: this.localPlayer.id,
            timestamp: Date.now()
        });
        
        this.setupPeerConnection();
        this.showLobby();
        
        return this.roomId;
    }

    joinRoom(roomId) {
        this.roomId = roomId;
        window.location.hash = roomId;
        
        this.broadcastSignal({
            type: 'join_request',
            roomId: roomId,
            player: this.localPlayer,
            timestamp: Date.now()
        });
        
        this.setupPeerConnection();
    }

    setupPeerConnection() {
        this.peer = new Peer(this.localPlayer.id);
        
        this.peer.on('open', (id) => {
            console.log('Peer connesso:', id);
        });
        
        this.peer.on('connection', (conn) => {
            this.setupDataChannel(conn);
        });
        
        this.peer.on('error', (err) => {
            console.error('Peer error:', err);
            this.fallbackToHotSeat();
        });
    }

    setupDataChannel(conn) {
        conn.on('open', () => {
            console.log('Connesso a:', conn.peer);
            this.connections.set(conn.peer, conn);
            this.players.set(conn.peer, { name: 'Opponent', score: 0 });
            
            if (this.isHost) {
                this.syncFullGameState();
            }
        });
        
        conn.on('data', (data) => {
            this.handleGameData(data);
        });
        
        conn.on('close', () => {
            this.connections.delete(conn.peer);
            this.players.delete(conn.peer);
            this.showMessage('Giocatore disconnesso');
        });
        
        this.dataChannel = conn;
    }

    connectToPlayer(playerId) {
        const conn = this.peer.connect(playerId);
        this.setupDataChannel(conn);
    }

    broadcastSignal(signal) {
        const signalData = {
            ...signal,
            from: this.localPlayer.id,
            roomId: this.roomId
        };
        
        localStorage.setItem('ballDrop_signal', JSON.stringify(signalData));
        setTimeout(() => localStorage.removeItem('ballDrop_signal'), 5000);
    }

    handleStorageEvent(event) {
        if (event.key !== 'ballDrop_signal' || !event.newValue) return;
        
        try {
            const signal = JSON.parse(event.newValue);
            if (signal.roomId !== this.roomId) return;
            
            this.processSignal(signal);
        } catch (e) {
            console.error('Errore parsing signal:', e);
        }
    }

    processSignal(signal) {
        switch (signal.type) {
            case 'room_created':
                if (!this.isHost) {
                    this.showRoomAvailable(signal);
                }
                break;
                
            case 'join_request':
                if (this.isHost && signal.player.id !== this.localPlayer.id) {
                    this.approveJoinRequest(signal);
                }
                break;
                
            case 'join_approved':
                if (!this.isHost && signal.to === this.localPlayer.id) {
                    this.connectToPlayer(signal.host);
                }
                break;
                
            case 'game_start':
                this.startMultiplayerGame();
                break;
        }
    }

    approveJoinRequest(signal) {
        this.broadcastSignal({
            type: 'join_approved',
            to: signal.player.id,
            host: this.localPlayer.id,
            roomId: this.roomId
        });
        
        this.connectToPlayer(signal.player.id);
    }

    syncFullGameState() {
        if (!this.dataChannel) return;
        
        const gameState = {
            type: 'full_sync',
            balls: this.game.balls.map(b => this.serializeBall(b)),
            score: this.game.score,
            level: this.game.level,
            players: Array.from(this.players.values()),
            timestamp: Date.now()
        };
        
        this.sendData(gameState);
    }

    syncGameUpdate() {
        if (!this.dataChannel) return;
        
        const update = {
            type: 'game_update',
            balls: this.game.balls.map(b => this.serializeBall(b)),
            score: this.game.score,
            level: this.game.level,
            timestamp: Date.now()
        };
        
        this.sendData(update);
    }

    syncPlayerAction(action, data) {
        this.sendData({
            type: 'player_action',
            action: action,
            data: data,
            player: this.localPlayer.id,
            timestamp: Date.now()
        });
    }

    serializeBall(ball) {
        return {
            x: Math.round(ball.x * 100) / 100,
            y: Math.round(ball.y * 100) / 100,
            type: ball.type,
            vx: Math.round(ball.vx * 100) / 100,
            vy: Math.round(ball.vy * 100) / 100,
            r: ball.r,
            asleep: ball.asleep
        };
    }

    deserializeBall(data) {
        const ball = new Ball(data.x, data.y, data.type);
        ball.vx = data.vx;
        ball.vy = data.vy;
        ball.asleep = data.asleep;
        return ball;
    }

    sendData(data) {
        if (this.dataChannel && this.dataChannel.readyState === 'open') {
            this.dataChannel.send(JSON.stringify(data));
        }
    }

    handleGameData(data) {
        try {
            const gameData = JSON.parse(data);
            this.processGameData(gameData);
        } catch (e) {
            console.error('Errore parsing game data:', e);
        }
    }

    processGameData(gameData) {
        switch (gameData.type) {
            case 'full_sync':
                this.applyFullSync(gameData);
                break;
                
            case 'game_update':
                this.applyGameUpdate(gameData);
                break;
                
            case 'player_action':
                this.handlePlayerAction(gameData);
                break;
                
            case 'score_update':
                this.updatePlayerScore(gameData);
                break;
        }
    }

    applyFullSync(data) {
        this.game.balls = data.balls.map(b => this.deserializeBall(b));
        this.game.score = data.score;
        this.game.level = data.level;
        
        data.players.forEach(player => {
            this.players.set(player.id, player);
        });
    }

    applyGameUpdate(data) {
        data.balls.forEach((ballData, index) => {
            if (index < this.game.balls.length) {
                const ball = this.game.balls[index];
                ball.x = ballData.x;
                ball.y = ballData.y;
                ball.vx = ballData.vx;
                ball.vy = ballData.vy;
            }
        });
        
        this.game.score = data.score;
        this.game.level = data.level;
    }

    startCoopMode() {
        this.gameMode = 'coop';
        this.syncInterval = setInterval(() => {
            this.syncGameUpdate();
        }, 100);
        
        this.showMessage('Modalit√† Cooperativa Attiva!');
    }

    startVersusMode() {
        this.gameMode = 'versus';
        this.setupVersusUI();
        this.showMessage('Modalit√† Versus Attiva!');
    }

    startDuelMode() {
        this.gameMode = 'duel';
        this.duelState = {
            startTime: Date.now(),
            timeLimit: 120000,
            scores: new Map()
        };
        
        this.setupDuelUI();
        this.showMessage('Duel Started!');
    }

    showLobby() {
        const lobbyHTML = `
            <div class="multiplayer-overlay">
                <div class="lobby">
                    <h2>Stanza Multiplayer</h2>
                    <div class="room-info">
                        <p>Codice Stanza: <strong>${this.roomId}</strong></p>
                        <p>Giocatori: <span id="playerCount">1</span>/4</p>
                    </div>
                    <div class="player-list" id="playerList">
                        <div class="player">${this.localPlayer.name} (Tu)</div>
                    </div>
                    <div class="lobby-buttons">
                        <button onclick="multiplayer.startCoopMode()">Cooperative</button>
                        <button onclick="multiplayer.startVersusMode()">Versus</button>
                        <button onclick="multiplayer.startDuelMode()">1v1 Duel</button>
                        <button onclick="multiplayer.leaveRoom()">Esci</button>
                    </div>
                </div>
            </div>
        `;
        
        this.showOverlay(lobbyHTML);
    }

    showOverlay(html) {
        let overlay = document.getElementById('multiplayerOverlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'multiplayerOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0; left: 0;
                width: 100%; height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            `;
            document.body.appendChild(overlay);
        }
        
        overlay.innerHTML = html;
    }

    hideOverlay() {
        const overlay = document.getElementById('multiplayerOverlay');
        if (overlay) {
            overlay.remove();
        }
    }

    showMessage(text) {
        floatText(text, W/2, H/2);
    }

    fallbackToHotSeat() {
        this.showMessage('Connessione fallita - Modalit√† Hot Seat');
        
        this.hotSeatMode = {
            players: [this.localPlayer],
            currentPlayer: 0,
            turn: 0
        };
        
        this.startHotSeatGame();
    }

    startHotSeatGame() {
        this.showHotSeatUI();
        this.game.resetGame();
    }

    leaveRoom() {
        if (this.dataChannel) {
            this.dataChannel.close();
        }
        
        if (this.peer) {
            this.peer.destroy();
        }
        
        this.connections.clear();
        this.players.clear();
        
        window.location.hash = '';
        this.hideOverlay();
        
        this.showMessage('Hai lasciato la stanza');
    }

    integrateWithGame() {
        const originalSpawn = this.game.spawnBall;
        this.game.spawnBall = (x, y, type) => {
            const ball = originalSpawn.call(this.game, x, y, type);
            if (ball && this.dataChannel) {
                this.syncPlayerAction('ball_spawn', { x, y, type });
            }
            return ball;
        };
        
        const originalUpdate = this.game.update;
        this.game.update = (dt) => {
            originalUpdate.call(this.game, dt);
            
            if (this.gameMode === 'coop' && this.lastSync + 100 < Date.now()) {
                this.syncGameUpdate();
                this.lastSync = Date.now();
            }
        };
    }
}

// Inizializza multiplayer
const multiplayer = new BallDropMultiplayer({
  resetGame,
  score: 0,
  level: 1,
  balls: [],
  update: () => {},
  spawnBall: (x, y, type) => {
    const ball = spawnBall(x, y, type);
    balls.push(ball);
    return ball;
  }
});


loop();
})();
</script>
</body>
</html>
